"use strict";

function _classCallCheck(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

function _classCallCheck(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

function _classCallCheck(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

function _classCallCheck(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

function _classCallCheck(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

function _classCallCheck(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

function _classCallCheck(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

function _classCallCheck(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

function _classCallCheck(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

function _classCallCheck(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}

var Util = function(t) {
    function e(t) {
        return {}.toString.call(t).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
    }
    function i(t) {
        return (t[0] || t).nodeType;
    }
    function n() {
        return {
            bindType: a.end,
            delegateType: a.end,
            handle: function(e) {
                if (t(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        };
    }
    function s() {
        if (window.QUnit) return !1;
        var t = document.createElement("bootstrap");
        for (var e in r) if (void 0 !== t.style[e]) return {
            end: r[e]
        };
        return !1;
    }
    function o(e) {
        var i = this, n = !1;
        return t(this).one(l.TRANSITION_END, function() {
            n = !0;
        }), setTimeout(function() {
            n || l.triggerTransitionEnd(i);
        }, e), this;
    }
    var a = !1, r = {
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "oTransitionEnd otransitionend",
        transition: "transitionend"
    }, l = {
        TRANSITION_END: "bsTransitionEnd",
        getUID: function(t) {
            do {
                t += ~~(1e6 * Math.random());
            } while (document.getElementById(t));
            return t;
        },
        getSelectorFromElement: function(t) {
            var e = t.getAttribute("data-target");
            return e || (e = t.getAttribute("href") || "", e = /^#[a-z]/i.test(e) ? e : null), 
            e;
        },
        reflow: function(t) {
            new Function("bs", "return bs")(t.offsetHeight);
        },
        triggerTransitionEnd: function(e) {
            t(e).trigger(a.end);
        },
        supportsTransitionEnd: function() {
            return Boolean(a);
        },
        typeCheckConfig: function(t, n, s) {
            for (var o in s) if (s.hasOwnProperty(o)) {
                var a = s[o], r = n[o], l = void 0;
                if (l = r && i(r) ? "element" : e(r), !new RegExp(a).test(l)) throw new Error(t.toUpperCase() + ': Option "' + o + '" provided type "' + l + '" but expected type "' + a + '".');
            }
        }
    };
    return function() {
        a = s(), t.fn.emulateTransitionEnd = o, l.supportsTransitionEnd() && (t.event.special[l.TRANSITION_END] = n());
    }(), l;
}(jQuery), _createClass = function() {
    function t(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
            Object.defineProperty(t, n.key, n);
        }
    }
    return function(e, i, n) {
        return i && t(e.prototype, i), n && t(e, n), e;
    };
}(), Alert = function(t) {
    var e = "alert", i = t.fn[e], n = {
        DISMISS: '[data-dismiss="alert"]'
    }, s = {
        CLOSE: "close.bs.alert",
        CLOSED: "closed.bs.alert",
        CLICK_DATA_API: "click.bs.alert.data-api"
    }, o = {
        ALERT: "alert",
        FADE: "fade",
        IN: "in"
    }, a = function() {
        function e(t) {
            _classCallCheck(this, e), this._element = t;
        }
        return _createClass(e, [ {
            key: "close",
            value: function(t) {
                t = t || this._element;
                var e = this._getRootElement(t);
                this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e);
            }
        }, {
            key: "dispose",
            value: function() {
                t.removeData(this._element, "bs.alert"), this._element = null;
            }
        }, {
            key: "_getRootElement",
            value: function(e) {
                var i = Util.getSelectorFromElement(e), n = !1;
                return i && (n = t(i)[0]), n || (n = t(e).closest("." + o.ALERT)[0]), n;
            }
        }, {
            key: "_triggerCloseEvent",
            value: function(e) {
                var i = t.Event(s.CLOSE);
                return t(e).trigger(i), i;
            }
        }, {
            key: "_removeElement",
            value: function(e) {
                if (t(e).removeClass(o.IN), !Util.supportsTransitionEnd() || !t(e).hasClass(o.FADE)) return void this._destroyElement(e);
                t(e).one(Util.TRANSITION_END, t.proxy(this._destroyElement, this, e)).emulateTransitionEnd(150);
            }
        }, {
            key: "_destroyElement",
            value: function(e) {
                t(e).detach().trigger(s.CLOSED).remove();
            }
        } ], [ {
            key: "_jQueryInterface",
            value: function(i) {
                return this.each(function() {
                    var n = t(this), s = n.data("bs.alert");
                    s || (s = new e(this), n.data("bs.alert", s)), "close" === i && s[i](this);
                });
            }
        }, {
            key: "_handleDismiss",
            value: function(t) {
                return function(e) {
                    e && e.preventDefault(), t.close(this);
                };
            }
        }, {
            key: "VERSION",
            get: function() {
                return "4.0.0";
            }
        } ]), e;
    }();
    return t(document).on(s.CLICK_DATA_API, n.DISMISS, a._handleDismiss(new a())), t.fn[e] = a._jQueryInterface, 
    t.fn[e].Constructor = a, t.fn[e].noConflict = function() {
        return t.fn[e] = i, a._jQueryInterface;
    }, a;
}(jQuery), _createClass = function() {
    function t(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
            Object.defineProperty(t, n.key, n);
        }
    }
    return function(e, i, n) {
        return i && t(e.prototype, i), n && t(e, n), e;
    };
}(), Button = function(t) {
    var e = "button", i = t.fn[e], n = {
        ACTIVE: "active",
        BUTTON: "btn",
        FOCUS: "focus"
    }, s = {
        DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
        DATA_TOGGLE: '[data-toggle="buttons"]',
        INPUT: "input",
        ACTIVE: ".active",
        BUTTON: ".btn"
    }, o = {
        CLICK_DATA_API: "click.bs.button.data-api",
        FOCUS_BLUR_DATA_API: "focus.bs.button.data-api blur.bs.button.data-api"
    }, a = function() {
        function e(t) {
            _classCallCheck(this, e), this._element = t;
        }
        return _createClass(e, [ {
            key: "toggle",
            value: function() {
                var e = !0, i = t(this._element).closest(s.DATA_TOGGLE)[0];
                if (i) {
                    var o = t(this._element).find(s.INPUT)[0];
                    if (o) {
                        if ("radio" === o.type) if (o.checked && t(this._element).hasClass(n.ACTIVE)) e = !1; else {
                            var a = t(i).find(s.ACTIVE)[0];
                            a && t(a).removeClass(n.ACTIVE);
                        }
                        e && (o.checked = !t(this._element).hasClass(n.ACTIVE), t(this._element).trigger("change"));
                    }
                } else this._element.setAttribute("aria-pressed", !t(this._element).hasClass(n.ACTIVE));
                e && t(this._element).toggleClass(n.ACTIVE);
            }
        }, {
            key: "dispose",
            value: function() {
                t.removeData(this._element, "bs.button"), this._element = null;
            }
        } ], [ {
            key: "_jQueryInterface",
            value: function(i) {
                return this.each(function() {
                    var n = t(this).data("bs.button");
                    n || (n = new e(this), t(this).data("bs.button", n)), "toggle" === i && n[i]();
                });
            }
        }, {
            key: "VERSION",
            get: function() {
                return "4.0.0";
            }
        } ]), e;
    }();
    return t(document).on(o.CLICK_DATA_API, s.DATA_TOGGLE_CARROT, function(e) {
        e.preventDefault();
        var i = e.target;
        t(i).hasClass(n.BUTTON) || (i = t(i).closest(s.BUTTON)), a._jQueryInterface.call(t(i), "toggle");
    }).on(o.FOCUS_BLUR_DATA_API, s.DATA_TOGGLE_CARROT, function(e) {
        var i = t(e.target).closest(s.BUTTON)[0];
        t(i).toggleClass(n.FOCUS, /^focus(in)?$/.test(e.type));
    }), t.fn[e] = a._jQueryInterface, t.fn[e].Constructor = a, t.fn[e].noConflict = function() {
        return t.fn[e] = i, a._jQueryInterface;
    }, a;
}(jQuery), _createClass = function() {
    function t(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
            Object.defineProperty(t, n.key, n);
        }
    }
    return function(e, i, n) {
        return i && t(e.prototype, i), n && t(e, n), e;
    };
}(), Carousel = function(t) {
    var e = "carousel", i = "bs.carousel", n = "." + i, s = t.fn[e], o = {
        interval: 5e3,
        keyboard: !0,
        slide: !1,
        pause: "hover",
        wrap: !0
    }, a = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        slide: "(boolean|string)",
        pause: "(string|boolean)",
        wrap: "boolean"
    }, r = {
        NEXT: "next",
        PREVIOUS: "prev"
    }, l = {
        SLIDE: "slide" + n,
        SLID: "slid" + n,
        KEYDOWN: "keydown" + n,
        MOUSEENTER: "mouseenter" + n,
        MOUSELEAVE: "mouseleave" + n,
        LOAD_DATA_API: "load.bs.carousel.data-api",
        CLICK_DATA_API: "click.bs.carousel.data-api"
    }, h = {
        CAROUSEL: "carousel",
        ACTIVE: "active",
        SLIDE: "slide",
        RIGHT: "right",
        LEFT: "left",
        ITEM: "carousel-item"
    }, c = {
        ACTIVE: ".active",
        ACTIVE_ITEM: ".active.carousel-item",
        ITEM: ".carousel-item",
        NEXT_PREV: ".next, .prev",
        INDICATORS: ".carousel-indicators",
        DATA_SLIDE: "[data-slide], [data-slide-to]",
        DATA_RIDE: '[data-ride="carousel"]'
    }, u = function() {
        function s(e, i) {
            _classCallCheck(this, s), this._items = null, this._interval = null, this._activeElement = null, 
            this._isPaused = !1, this._isSliding = !1, this._config = this._getConfig(i), this._element = t(e)[0], 
            this._indicatorsElement = t(this._element).find(c.INDICATORS)[0], this._addEventListeners();
        }
        return _createClass(s, [ {
            key: "next",
            value: function() {
                this._isSliding || this._slide(r.NEXT);
            }
        }, {
            key: "prev",
            value: function() {
                this._isSliding || this._slide(r.PREVIOUS);
            }
        }, {
            key: "pause",
            value: function(e) {
                e || (this._isPaused = !0), t(this._element).find(c.NEXT_PREV)[0] && Util.supportsTransitionEnd() && (Util.triggerTransitionEnd(this._element), 
                this.cycle(!0)), clearInterval(this._interval), this._interval = null;
            }
        }, {
            key: "cycle",
            value: function(e) {
                e || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), 
                this._config.interval && !this._isPaused && (this._interval = setInterval(t.proxy(this.next, this), this._config.interval));
            }
        }, {
            key: "to",
            value: function(e) {
                var i = this;
                this._activeElement = t(this._element).find(c.ACTIVE_ITEM)[0];
                var n = this._getItemIndex(this._activeElement);
                if (!(e > this._items.length - 1 || e < 0)) {
                    if (this._isSliding) return void t(this._element).one(l.SLID, function() {
                        return i.to(e);
                    });
                    if (n === e) return this.pause(), void this.cycle();
                    var s = e > n ? r.NEXT : r.PREVIOUS;
                    this._slide(s, this._items[e]);
                }
            }
        }, {
            key: "dispose",
            value: function() {
                t(this._element).off(n), t.removeData(this._element, i), this._items = null, this._config = null, 
                this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, 
                this._activeElement = null, this._indicatorsElement = null;
            }
        }, {
            key: "_getConfig",
            value: function(i) {
                return i = t.extend({}, o, i), Util.typeCheckConfig(e, i, a), i;
            }
        }, {
            key: "_addEventListeners",
            value: function() {
                this._config.keyboard && t(this._element).on(l.KEYDOWN, t.proxy(this._keydown, this)), 
                "hover" !== this._config.pause || "ontouchstart" in document.documentElement || t(this._element).on(l.MOUSEENTER, t.proxy(this.pause, this)).on(l.MOUSELEAVE, t.proxy(this.cycle, this));
            }
        }, {
            key: "_keydown",
            value: function(t) {
                if (t.preventDefault(), !/input|textarea/i.test(t.target.tagName)) switch (t.which) {
                  case 37:
                    this.prev();
                    break;

                  case 39:
                    this.next();
                    break;

                  default:
                    return;
                }
            }
        }, {
            key: "_getItemIndex",
            value: function(e) {
                return this._items = t.makeArray(t(e).parent().find(c.ITEM)), this._items.indexOf(e);
            }
        }, {
            key: "_getItemByDirection",
            value: function(t, e) {
                var i = t === r.NEXT, n = t === r.PREVIOUS, s = this._getItemIndex(e), o = this._items.length - 1;
                if ((n && 0 === s || i && s === o) && !this._config.wrap) return e;
                var a = (s + (t === r.PREVIOUS ? -1 : 1)) % this._items.length;
                return -1 === a ? this._items[this._items.length - 1] : this._items[a];
            }
        }, {
            key: "_triggerSlideEvent",
            value: function(e, i) {
                var n = t.Event(l.SLIDE, {
                    relatedTarget: e,
                    direction: i
                });
                return t(this._element).trigger(n), n;
            }
        }, {
            key: "_setActiveIndicatorElement",
            value: function(e) {
                if (this._indicatorsElement) {
                    t(this._indicatorsElement).find(c.ACTIVE).removeClass(h.ACTIVE);
                    var i = this._indicatorsElement.children[this._getItemIndex(e)];
                    i && t(i).addClass(h.ACTIVE);
                }
            }
        }, {
            key: "_slide",
            value: function(e, i) {
                var n = this, s = t(this._element).find(c.ACTIVE_ITEM)[0], o = i || s && this._getItemByDirection(e, s), a = Boolean(this._interval), u = e === r.NEXT ? h.LEFT : h.RIGHT;
                if (o && t(o).hasClass(h.ACTIVE)) return void (this._isSliding = !1);
                if (!this._triggerSlideEvent(o, u).isDefaultPrevented() && s && o) {
                    this._isSliding = !0, a && this.pause(), this._setActiveIndicatorElement(o);
                    var d = t.Event(l.SLID, {
                        relatedTarget: o,
                        direction: u
                    });
                    Util.supportsTransitionEnd() && t(this._element).hasClass(h.SLIDE) ? (t(o).addClass(e), 
                    Util.reflow(o), t(s).addClass(u), t(o).addClass(u), t(s).one(Util.TRANSITION_END, function() {
                        t(o).removeClass(u).removeClass(e), t(o).addClass(h.ACTIVE), t(s).removeClass(h.ACTIVE).removeClass(e).removeClass(u), 
                        n._isSliding = !1, setTimeout(function() {
                            return t(n._element).trigger(d);
                        }, 0);
                    }).emulateTransitionEnd(600)) : (t(s).removeClass(h.ACTIVE), t(o).addClass(h.ACTIVE), 
                    this._isSliding = !1, t(this._element).trigger(d)), a && this.cycle();
                }
            }
        } ], [ {
            key: "_jQueryInterface",
            value: function(e) {
                return this.each(function() {
                    var n = t(this).data(i), a = t.extend({}, o, t(this).data());
                    "object" == typeof e && t.extend(a, e);
                    var r = "string" == typeof e ? e : a.slide;
                    n || (n = new s(this, a), t(this).data(i, n)), "number" == typeof e ? n.to(e) : r ? n[r]() : a.interval && (n.pause(), 
                    n.cycle());
                });
            }
        }, {
            key: "_dataApiClickHandler",
            value: function(e) {
                var n = Util.getSelectorFromElement(this);
                if (n) {
                    var o = t(n)[0];
                    if (o && t(o).hasClass(h.CAROUSEL)) {
                        var a = t.extend({}, t(o).data(), t(this).data()), r = this.getAttribute("data-slide-to");
                        r && (a.interval = !1), s._jQueryInterface.call(t(o), a), r && t(o).data(i).to(r), 
                        e.preventDefault();
                    }
                }
            }
        }, {
            key: "VERSION",
            get: function() {
                return "4.0.0";
            }
        }, {
            key: "Default",
            get: function() {
                return o;
            }
        } ]), s;
    }();
    return t(document).on(l.CLICK_DATA_API, c.DATA_SLIDE, u._dataApiClickHandler), t(window).on(l.LOAD_DATA_API, function() {
        t(c.DATA_RIDE).each(function() {
            var e = t(this);
            u._jQueryInterface.call(e, e.data());
        });
    }), t.fn[e] = u._jQueryInterface, t.fn[e].Constructor = u, t.fn[e].noConflict = function() {
        return t.fn[e] = s, u._jQueryInterface;
    }, u;
}(jQuery), _createClass = function() {
    function t(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
            Object.defineProperty(t, n.key, n);
        }
    }
    return function(e, i, n) {
        return i && t(e.prototype, i), n && t(e, n), e;
    };
}(), Collapse = function(t) {
    var e = "collapse", i = "bs.collapse", n = t.fn[e], s = {
        toggle: !0,
        parent: ""
    }, o = {
        toggle: "boolean",
        parent: "string"
    }, a = {
        SHOW: "show.bs.collapse",
        SHOWN: "shown.bs.collapse",
        HIDE: "hide.bs.collapse",
        HIDDEN: "hidden.bs.collapse",
        CLICK_DATA_API: "click.bs.collapse.data-api"
    }, r = {
        IN: "in",
        COLLAPSE: "collapse",
        COLLAPSING: "collapsing",
        COLLAPSED: "collapsed"
    }, l = {
        WIDTH: "width",
        HEIGHT: "height"
    }, h = {
        ACTIVES: ".panel > .in, .panel > .collapsing",
        DATA_TOGGLE: '[data-toggle="collapse"]'
    }, c = function() {
        function n(e, i) {
            _classCallCheck(this, n), this._isTransitioning = !1, this._element = e, this._config = this._getConfig(i), 
            this._triggerArray = t.makeArray(t('[data-toggle="collapse"][href="#' + e.id + '"],[data-toggle="collapse"][data-target="#' + e.id + '"]')), 
            this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), 
            this._config.toggle && this.toggle();
        }
        return _createClass(n, [ {
            key: "toggle",
            value: function() {
                t(this._element).hasClass(r.IN) ? this.hide() : this.show();
            }
        }, {
            key: "show",
            value: function() {
                var e = this;
                if (!this._isTransitioning && !t(this._element).hasClass(r.IN)) {
                    var s = void 0, o = void 0;
                    if (this._parent && ((s = t.makeArray(t(h.ACTIVES))).length || (s = null)), !(s && (o = t(s).data(i)) && o._isTransitioning)) {
                        var l = t.Event(a.SHOW);
                        if (t(this._element).trigger(l), !l.isDefaultPrevented()) {
                            s && (n._jQueryInterface.call(t(s), "hide"), o || t(s).data(i, null));
                            var c = this._getDimension();
                            t(this._element).removeClass(r.COLLAPSE).addClass(r.COLLAPSING), this._element.style[c] = 0, 
                            this._element.setAttribute("aria-expanded", !0), this._triggerArray.length && t(this._triggerArray).removeClass(r.COLLAPSED).attr("aria-expanded", !0), 
                            this.setTransitioning(!0);
                            var u = function() {
                                t(e._element).removeClass(r.COLLAPSING).addClass(r.COLLAPSE).addClass(r.IN), e._element.style[c] = "", 
                                e.setTransitioning(!1), t(e._element).trigger(a.SHOWN);
                            };
                            if (!Util.supportsTransitionEnd()) return void u();
                            var d = "scroll" + (c[0].toUpperCase() + c.slice(1));
                            t(this._element).one(Util.TRANSITION_END, u).emulateTransitionEnd(600), this._element.style[c] = this._element[d] + "px";
                        }
                    }
                }
            }
        }, {
            key: "hide",
            value: function() {
                var e = this;
                if (!this._isTransitioning && t(this._element).hasClass(r.IN)) {
                    var i = t.Event(a.HIDE);
                    if (t(this._element).trigger(i), !i.isDefaultPrevented()) {
                        var n = this._getDimension(), s = n === l.WIDTH ? "offsetWidth" : "offsetHeight";
                        this._element.style[n] = this._element[s] + "px", Util.reflow(this._element), t(this._element).addClass(r.COLLAPSING).removeClass(r.COLLAPSE).removeClass(r.IN), 
                        this._element.setAttribute("aria-expanded", !1), this._triggerArray.length && t(this._triggerArray).addClass(r.COLLAPSED).attr("aria-expanded", !1), 
                        this.setTransitioning(!0);
                        var o = function() {
                            e.setTransitioning(!1), t(e._element).removeClass(r.COLLAPSING).addClass(r.COLLAPSE).trigger(a.HIDDEN);
                        };
                        if (this._element.style[n] = 0, !Util.supportsTransitionEnd()) return void o();
                        t(this._element).one(Util.TRANSITION_END, o).emulateTransitionEnd(600);
                    }
                }
            }
        }, {
            key: "setTransitioning",
            value: function(t) {
                this._isTransitioning = t;
            }
        }, {
            key: "dispose",
            value: function() {
                t.removeData(this._element, i), this._config = null, this._parent = null, this._element = null, 
                this._triggerArray = null, this._isTransitioning = null;
            }
        }, {
            key: "_getConfig",
            value: function(i) {
                return i = t.extend({}, s, i), i.toggle = Boolean(i.toggle), Util.typeCheckConfig(e, i, o), 
                i;
            }
        }, {
            key: "_getDimension",
            value: function() {
                return t(this._element).hasClass(l.WIDTH) ? l.WIDTH : l.HEIGHT;
            }
        }, {
            key: "_getParent",
            value: function() {
                var e = this, i = t(this._config.parent)[0], s = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]';
                return t(i).find(s).each(function(t, i) {
                    e._addAriaAndCollapsedClass(n._getTargetFromElement(i), [ i ]);
                }), i;
            }
        }, {
            key: "_addAriaAndCollapsedClass",
            value: function(e, i) {
                if (e) {
                    var n = t(e).hasClass(r.IN);
                    e.setAttribute("aria-expanded", n), i.length && t(i).toggleClass(r.COLLAPSED, !n).attr("aria-expanded", n);
                }
            }
        } ], [ {
            key: "_getTargetFromElement",
            value: function(e) {
                var i = Util.getSelectorFromElement(e);
                return i ? t(i)[0] : null;
            }
        }, {
            key: "_jQueryInterface",
            value: function(e) {
                return this.each(function() {
                    var o = t(this), a = o.data(i), r = t.extend({}, s, o.data(), "object" == typeof e && e);
                    !a && r.toggle && /show|hide/.test(e) && (r.toggle = !1), a || (a = new n(this, r), 
                    o.data(i, a)), "string" == typeof e && a[e]();
                });
            }
        }, {
            key: "VERSION",
            get: function() {
                return "4.0.0";
            }
        }, {
            key: "Default",
            get: function() {
                return s;
            }
        } ]), n;
    }();
    return t(document).on(a.CLICK_DATA_API, h.DATA_TOGGLE, function(e) {
        e.preventDefault();
        var n = c._getTargetFromElement(this), s = t(n).data(i) ? "toggle" : t(this).data();
        c._jQueryInterface.call(t(n), s);
    }), t.fn[e] = c._jQueryInterface, t.fn[e].Constructor = c, t.fn[e].noConflict = function() {
        return t.fn[e] = n, c._jQueryInterface;
    }, c;
}(jQuery), _createClass = function() {
    function t(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
            Object.defineProperty(t, n.key, n);
        }
    }
    return function(e, i, n) {
        return i && t(e.prototype, i), n && t(e, n), e;
    };
}(), Dropdown = function(t) {
    var e = "dropdown", i = ".bs.dropdown", n = t.fn[e], s = {
        HIDE: "hide" + i,
        HIDDEN: "hidden" + i,
        SHOW: "show" + i,
        SHOWN: "shown" + i,
        CLICK: "click" + i,
        CLICK_DATA_API: "click.bs.dropdown.data-api",
        KEYDOWN_DATA_API: "keydown.bs.dropdown.data-api"
    }, o = {
        BACKDROP: "dropdown-backdrop",
        DISABLED: "disabled",
        OPEN: "open"
    }, a = {
        BACKDROP: ".dropdown-backdrop",
        DATA_TOGGLE: '[data-toggle="dropdown"]',
        FORM_CHILD: ".dropdown form",
        ROLE_MENU: '[role="menu"]',
        ROLE_LISTBOX: '[role="listbox"]',
        NAVBAR_NAV: ".navbar-nav",
        VISIBLE_ITEMS: '[role="menu"] li:not(.disabled) a, [role="listbox"] li:not(.disabled) a'
    }, r = function() {
        function e(t) {
            _classCallCheck(this, e), this._element = t, this._addEventListeners();
        }
        return _createClass(e, [ {
            key: "toggle",
            value: function() {
                if (this.disabled || t(this).hasClass(o.DISABLED)) return !1;
                var i = e._getParentFromElement(this), n = t(i).hasClass(o.OPEN);
                if (e._clearMenus(), n) return !1;
                if ("ontouchstart" in document.documentElement && !t(i).closest(a.NAVBAR_NAV).length) {
                    var r = document.createElement("div");
                    r.className = o.BACKDROP, t(r).insertBefore(this), t(r).on("click", e._clearMenus);
                }
                var l = {
                    relatedTarget: this
                }, h = t.Event(s.SHOW, l);
                return t(i).trigger(h), !h.isDefaultPrevented() && (this.focus(), this.setAttribute("aria-expanded", "true"), 
                t(i).toggleClass(o.OPEN), t(i).trigger(t.Event(s.SHOWN, l)), !1);
            }
        }, {
            key: "dispose",
            value: function() {
                t.removeData(this._element, "bs.dropdown"), t(this._element).off(i), this._element = null;
            }
        }, {
            key: "_addEventListeners",
            value: function() {
                t(this._element).on(s.CLICK, this.toggle);
            }
        } ], [ {
            key: "_jQueryInterface",
            value: function(i) {
                return this.each(function() {
                    var n = t(this).data("bs.dropdown");
                    n || t(this).data("bs.dropdown", n = new e(this)), "string" == typeof i && n[i].call(this);
                });
            }
        }, {
            key: "_clearMenus",
            value: function(i) {
                if (!i || 3 !== i.which) {
                    var n = t(a.BACKDROP)[0];
                    n && n.parentNode.removeChild(n);
                    for (var r = t.makeArray(t(a.DATA_TOGGLE)), l = 0; l < r.length; l++) {
                        var h = e._getParentFromElement(r[l]), c = {
                            relatedTarget: r[l]
                        };
                        if (t(h).hasClass(o.OPEN) && !(i && "click" === i.type && /input|textarea/i.test(i.target.tagName) && t.contains(h, i.target))) {
                            var u = t.Event(s.HIDE, c);
                            t(h).trigger(u), u.isDefaultPrevented() || (r[l].setAttribute("aria-expanded", "false"), 
                            t(h).removeClass(o.OPEN).trigger(t.Event(s.HIDDEN, c)));
                        }
                    }
                }
            }
        }, {
            key: "_getParentFromElement",
            value: function(e) {
                var i = void 0, n = Util.getSelectorFromElement(e);
                return n && (i = t(n)[0]), i || e.parentNode;
            }
        }, {
            key: "_dataApiKeydownHandler",
            value: function(i) {
                if (/(38|40|27|32)/.test(i.which) && !/input|textarea/i.test(i.target.tagName) && (i.preventDefault(), 
                i.stopPropagation(), !this.disabled && !t(this).hasClass(o.DISABLED))) {
                    var n = e._getParentFromElement(this), s = t(n).hasClass(o.OPEN);
                    if (!s && 27 !== i.which || s && 27 === i.which) {
                        if (27 === i.which) {
                            var r = t(n).find(a.DATA_TOGGLE)[0];
                            t(r).trigger("focus");
                        }
                        return void t(this).trigger("click");
                    }
                    var l = t.makeArray(t(a.VISIBLE_ITEMS));
                    if ((l = l.filter(function(t) {
                        return t.offsetWidth || t.offsetHeight;
                    })).length) {
                        var h = l.indexOf(i.target);
                        38 === i.which && h > 0 && h--, 40 === i.which && h < l.length - 1 && h++, ~h || (h = 0), 
                        l[h].focus();
                    }
                }
            }
        }, {
            key: "VERSION",
            get: function() {
                return "4.0.0";
            }
        } ]), e;
    }();
    return t(document).on(s.KEYDOWN_DATA_API, a.DATA_TOGGLE, r._dataApiKeydownHandler).on(s.KEYDOWN_DATA_API, a.ROLE_MENU, r._dataApiKeydownHandler).on(s.KEYDOWN_DATA_API, a.ROLE_LISTBOX, r._dataApiKeydownHandler).on(s.CLICK_DATA_API, r._clearMenus).on(s.CLICK_DATA_API, a.DATA_TOGGLE, r.prototype.toggle).on(s.CLICK_DATA_API, a.FORM_CHILD, function(t) {
        t.stopPropagation();
    }), t.fn[e] = r._jQueryInterface, t.fn[e].Constructor = r, t.fn[e].noConflict = function() {
        return t.fn[e] = n, r._jQueryInterface;
    }, r;
}(jQuery), _createClass = function() {
    function t(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
            Object.defineProperty(t, n.key, n);
        }
    }
    return function(e, i, n) {
        return i && t(e.prototype, i), n && t(e, n), e;
    };
}(), Modal = function(t) {
    var e = "modal", i = ".bs.modal", n = t.fn[e], s = {
        backdrop: !0,
        keyboard: !0,
        focus: !0,
        show: !0
    }, o = {
        backdrop: "(boolean|string)",
        keyboard: "boolean",
        focus: "boolean",
        show: "boolean"
    }, a = {
        HIDE: "hide.bs.modal",
        HIDDEN: "hidden.bs.modal",
        SHOW: "show.bs.modal",
        SHOWN: "shown.bs.modal",
        FOCUSIN: "focusin.bs.modal",
        RESIZE: "resize.bs.modal",
        CLICK_DISMISS: "click.dismiss.bs.modal",
        KEYDOWN_DISMISS: "keydown.dismiss.bs.modal",
        MOUSEUP_DISMISS: "mouseup.dismiss.bs.modal",
        MOUSEDOWN_DISMISS: "mousedown.dismiss.bs.modal",
        CLICK_DATA_API: "click.bs.modal.data-api"
    }, r = {
        SCROLLBAR_MEASURER: "modal-scrollbar-measure",
        BACKDROP: "modal-backdrop",
        OPEN: "modal-open",
        FADE: "fade",
        IN: "in"
    }, l = {
        DIALOG: ".modal-dialog",
        DATA_TOGGLE: '[data-toggle="modal"]',
        DATA_DISMISS: '[data-dismiss="modal"]',
        FIXED_CONTENT: ".navbar-fixed-top, .navbar-fixed-bottom, .is-fixed"
    }, h = function() {
        function n(e, i) {
            _classCallCheck(this, n), this._config = this._getConfig(i), this._element = e, 
            this._dialog = t(e).find(l.DIALOG)[0], this._backdrop = null, this._isShown = !1, 
            this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._originalBodyPadding = 0, 
            this._scrollbarWidth = 0;
        }
        return _createClass(n, [ {
            key: "toggle",
            value: function(t) {
                return this._isShown ? this.hide() : this.show(t);
            }
        }, {
            key: "show",
            value: function(e) {
                var i = this, n = t.Event(a.SHOW, {
                    relatedTarget: e
                });
                t(this._element).trigger(n), this._isShown || n.isDefaultPrevented() || (this._isShown = !0, 
                this._checkScrollbar(), this._setScrollbar(), t(document.body).addClass(r.OPEN), 
                this._setEscapeEvent(), this._setResizeEvent(), t(this._element).on(a.CLICK_DISMISS, l.DATA_DISMISS, t.proxy(this.hide, this)), 
                t(this._dialog).on(a.MOUSEDOWN_DISMISS, function() {
                    t(i._element).one(a.MOUSEUP_DISMISS, function(e) {
                        t(e.target).is(i._element) && (that._ignoreBackdropClick = !0);
                    });
                }), this._showBackdrop(t.proxy(this._showElement, this, e)));
            }
        }, {
            key: "hide",
            value: function(e) {
                e && e.preventDefault();
                var i = t.Event(a.HIDE);
                t(this._element).trigger(i), this._isShown && !i.isDefaultPrevented() && (this._isShown = !1, 
                this._setEscapeEvent(), this._setResizeEvent(), t(document).off(a.FOCUSIN), t(this._element).removeClass(r.IN), 
                t(this._element).off(a.CLICK_DISMISS), t(this._dialog).off(a.MOUSEDOWN_DISMISS), 
                Util.supportsTransitionEnd() && t(this._element).hasClass(r.FADE) ? t(this._element).one(Util.TRANSITION_END, t.proxy(this._hideModal, this)).emulateTransitionEnd(300) : this._hideModal());
            }
        }, {
            key: "dispose",
            value: function() {
                t.removeData(this._element, "bs.modal"), t(window).off(i), t(document).off(i), t(this._element).off(i), 
                t(this._backdrop).off(i), this._config = null, this._element = null, this._dialog = null, 
                this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, 
                this._originalBodyPadding = null, this._scrollbarWidth = null;
            }
        }, {
            key: "_getConfig",
            value: function(i) {
                return i = t.extend({}, s, i), Util.typeCheckConfig(e, i, o), i;
            }
        }, {
            key: "_showElement",
            value: function(e) {
                var i = this, n = Util.supportsTransitionEnd() && t(this._element).hasClass(r.FADE);
                this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), 
                this._element.style.display = "block", this._element.scrollTop = 0, n && Util.reflow(this._element), 
                t(this._element).addClass(r.IN), this._config.focus && this._enforceFocus();
                var s = t.Event(a.SHOWN, {
                    relatedTarget: e
                }), o = function() {
                    i._config.focus && i._element.focus(), t(i._element).trigger(s);
                };
                n ? t(this._dialog).one(Util.TRANSITION_END, o).emulateTransitionEnd(300) : o();
            }
        }, {
            key: "_enforceFocus",
            value: function() {
                var e = this;
                t(document).off(a.FOCUSIN).on(a.FOCUSIN, function(i) {
                    e._element === i.target || t(e._element).has(i.target).length || e._element.focus();
                });
            }
        }, {
            key: "_setEscapeEvent",
            value: function() {
                var e = this;
                this._isShown && this._config.keyboard ? t(this._element).on(a.KEYDOWN_DISMISS, function(t) {
                    27 === t.which && e.hide();
                }) : this._isShown || t(this._element).off(a.KEYDOWN_DISMISS);
            }
        }, {
            key: "_setResizeEvent",
            value: function() {
                this._isShown ? t(window).on(a.RESIZE, t.proxy(this._handleUpdate, this)) : t(window).off(a.RESIZE);
            }
        }, {
            key: "_hideModal",
            value: function() {
                var e = this;
                this._element.style.display = "none", this._showBackdrop(function() {
                    t(document.body).removeClass(r.OPEN), e._resetAdjustments(), e._resetScrollbar(), 
                    t(e._element).trigger(a.HIDDEN);
                });
            }
        }, {
            key: "_removeBackdrop",
            value: function() {
                this._backdrop && (t(this._backdrop).remove(), this._backdrop = null);
            }
        }, {
            key: "_showBackdrop",
            value: function(e) {
                var i = this, n = t(this._element).hasClass(r.FADE) ? r.FADE : "";
                if (this._isShown && this._config.backdrop) {
                    var s = Util.supportsTransitionEnd() && n;
                    if (this._backdrop = document.createElement("div"), this._backdrop.className = r.BACKDROP, 
                    n && t(this._backdrop).addClass(n), t(this._backdrop).appendTo(document.body), t(this._element).on(a.CLICK_DISMISS, function(t) {
                        if (i._ignoreBackdropClick) return void (i._ignoreBackdropClick = !1);
                        t.target === t.currentTarget && ("static" === i._config.backdrop ? i._element.focus() : i.hide());
                    }), s && Util.reflow(this._backdrop), t(this._backdrop).addClass(r.IN), !e) return;
                    if (!s) return void e();
                    t(this._backdrop).one(Util.TRANSITION_END, e).emulateTransitionEnd(150);
                } else if (!this._isShown && this._backdrop) {
                    t(this._backdrop).removeClass(r.IN);
                    var o = function() {
                        i._removeBackdrop(), e && e();
                    };
                    Util.supportsTransitionEnd() && t(this._element).hasClass(r.FADE) ? t(this._backdrop).one(Util.TRANSITION_END, o).emulateTransitionEnd(150) : o();
                } else e && e();
            }
        }, {
            key: "_handleUpdate",
            value: function() {
                this._adjustDialog();
            }
        }, {
            key: "_adjustDialog",
            value: function() {
                var t = this._element.scrollHeight > document.documentElement.clientHeight;
                !this._isBodyOverflowing && t && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), 
                this._isBodyOverflowing && !t && (this._element.style.paddingRight = this._scrollbarWidth + "px~");
            }
        }, {
            key: "_resetAdjustments",
            value: function() {
                this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
            }
        }, {
            key: "_checkScrollbar",
            value: function() {
                var t = window.innerWidth;
                if (!t) {
                    var e = document.documentElement.getBoundingClientRect();
                    t = e.right - Math.abs(e.left);
                }
                this._isBodyOverflowing = document.body.clientWidth < t, this._scrollbarWidth = this._getScrollbarWidth();
            }
        }, {
            key: "_setScrollbar",
            value: function() {
                var e = parseInt(t(l.FIXED_CONTENT).css("padding-right") || 0, 10);
                this._originalBodyPadding = document.body.style.paddingRight || "", this._isBodyOverflowing && (document.body.style.paddingRight = e + (this._scrollbarWidth + "px"));
            }
        }, {
            key: "_resetScrollbar",
            value: function() {
                document.body.style.paddingRight = this._originalBodyPadding;
            }
        }, {
            key: "_getScrollbarWidth",
            value: function() {
                var t = document.createElement("div");
                t.className = r.SCROLLBAR_MEASURER, document.body.appendChild(t);
                var e = t.offsetWidth - t.clientWidth;
                return document.body.removeChild(t), e;
            }
        } ], [ {
            key: "_jQueryInterface",
            value: function(e, i) {
                return this.each(function() {
                    var s = t(this).data("bs.modal"), o = t.extend({}, n.Default, t(this).data(), "object" == typeof e && e);
                    s || (s = new n(this, o), t(this).data("bs.modal", s)), "string" == typeof e ? s[e](i) : o.show && s.show(i);
                });
            }
        }, {
            key: "VERSION",
            get: function() {
                return "4.0.0";
            }
        }, {
            key: "Default",
            get: function() {
                return s;
            }
        } ]), n;
    }();
    return t(document).on(a.CLICK_DATA_API, l.DATA_TOGGLE, function(e) {
        var i = this, n = void 0, s = Util.getSelectorFromElement(this);
        s && (n = t(s)[0]);
        var o = t(n).data("bs.modal") ? "toggle" : t.extend({}, t(n).data(), t(this).data());
        "A" === this.tagName && e.preventDefault();
        var r = t(n).one(a.SHOW, function(e) {
            e.isDefaultPrevented() || r.one(a.HIDDEN, function() {
                t(i).is(":visible") && i.focus();
            });
        });
        h._jQueryInterface.call(t(n), o, this);
    }), t.fn[e] = h._jQueryInterface, t.fn[e].Constructor = h, t.fn[e].noConflict = function() {
        return t.fn[e] = n, h._jQueryInterface;
    }, h;
}(jQuery), _createClass = function() {
    function t(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
            Object.defineProperty(t, n.key, n);
        }
    }
    return function(e, i, n) {
        return i && t(e.prototype, i), n && t(e, n), e;
    };
}(), ScrollSpy = function(t) {
    var e = "scrollspy", i = t.fn[e], n = {
        offset: 10,
        method: "auto",
        target: ""
    }, s = {
        offset: "number",
        method: "string",
        target: "(string|element)"
    }, o = {
        ACTIVATE: "activate.bs.scrollspy",
        SCROLL: "scroll.bs.scrollspy",
        LOAD_DATA_API: "load.bs.scrollspy.data-api"
    }, a = {
        DROPDOWN_ITEM: "dropdown-item",
        DROPDOWN_MENU: "dropdown-menu",
        NAV_LINK: "nav-link",
        NAV: "nav",
        ACTIVE: "active"
    }, r = {
        DATA_SPY: '[data-spy="scroll"]',
        ACTIVE: ".active",
        LIST_ITEM: ".list-item",
        LI: "li",
        LI_DROPDOWN: "li.dropdown",
        NAV_LINKS: ".nav-link",
        DROPDOWN: ".dropdown",
        DROPDOWN_ITEMS: ".dropdown-item",
        DROPDOWN_TOGGLE: ".dropdown-toggle"
    }, l = {
        OFFSET: "offset",
        POSITION: "position"
    }, h = function() {
        function i(e, n) {
            _classCallCheck(this, i), this._element = e, this._scrollElement = "BODY" === e.tagName ? window : e, 
            this._config = this._getConfig(n), this._selector = this._config.target + " " + r.NAV_LINKS + "," + this._config.target + " " + r.DROPDOWN_ITEMS, 
            this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, 
            t(this._scrollElement).on(o.SCROLL, t.proxy(this._process, this)), this.refresh(), 
            this._process();
        }
        return _createClass(i, [ {
            key: "refresh",
            value: function() {
                var e = this, i = this._scrollElement !== this._scrollElement.window ? l.POSITION : l.OFFSET, n = "auto" === this._config.method ? i : this._config.method, s = n === l.POSITION ? this._getScrollTop() : 0;
                this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), 
                t.makeArray(t(this._selector)).map(function(e) {
                    var i = void 0, o = Util.getSelectorFromElement(e);
                    if (o && (i = t(o)[0]), i && (i.offsetWidth || i.offsetHeight)) return [ t(i)[n]().top + s, o ];
                }).filter(function(t) {
                    return t;
                }).sort(function(t, e) {
                    return t[0] - e[0];
                }).forEach(function(t) {
                    e._offsets.push(t[0]), e._targets.push(t[1]);
                });
            }
        }, {
            key: "dispose",
            value: function() {
                t.removeData(this._element, "bs.scrollspy"), t(this._scrollElement).off(".bs.scrollspy"), 
                this._element = null, this._scrollElement = null, this._config = null, this._selector = null, 
                this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null;
            }
        }, {
            key: "_getConfig",
            value: function(i) {
                if ("string" != typeof (i = t.extend({}, n, i)).target) {
                    var o = t(i.target).attr("id");
                    o || (o = Util.getUID(e), t(i.target).attr("id", o)), i.target = "#" + o;
                }
                return Util.typeCheckConfig(e, i, s), i;
            }
        }, {
            key: "_getScrollTop",
            value: function() {
                return this._scrollElement === window ? this._scrollElement.scrollY : this._scrollElement.scrollTop;
            }
        }, {
            key: "_getScrollHeight",
            value: function() {
                return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
            }
        }, {
            key: "_process",
            value: function() {
                var t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), i = this._config.offset + e - this._scrollElement.offsetHeight;
                if (this._scrollHeight !== e && this.refresh(), t >= i) {
                    var n = this._targets[this._targets.length - 1];
                    this._activeTarget !== n && this._activate(n);
                }
                if (this._activeTarget && t < this._offsets[0]) return this._activeTarget = null, 
                void this._clear();
                for (var s = this._offsets.length; s--; ) this._activeTarget !== this._targets[s] && t >= this._offsets[s] && (void 0 === this._offsets[s + 1] || t < this._offsets[s + 1]) && this._activate(this._targets[s]);
            }
        }, {
            key: "_activate",
            value: function(e) {
                this._activeTarget = e, this._clear();
                var i = this._selector.split(",");
                i = i.map(function(t) {
                    return t + '[data-target="' + e + '"],' + t + '[href="' + e + '"]';
                });
                var n = t(i.join(","));
                n.hasClass(a.DROPDOWN_ITEM) ? (n.closest(r.DROPDOWN).find(r.DROPDOWN_TOGGLE).addClass(a.ACTIVE), 
                n.addClass(a.ACTIVE)) : n.parents(r.LI).find(r.NAV_LINKS).addClass(a.ACTIVE), t(this._scrollElement).trigger(o.ACTIVATE, {
                    relatedTarget: e
                });
            }
        }, {
            key: "_clear",
            value: function() {
                t(this._selector).filter(r.ACTIVE).removeClass(a.ACTIVE);
            }
        } ], [ {
            key: "_jQueryInterface",
            value: function(e) {
                return this.each(function() {
                    var n = t(this).data("bs.scrollspy"), s = "object" == typeof e && e || null;
                    n || (n = new i(this, s), t(this).data("bs.scrollspy", n)), "string" == typeof e && n[e]();
                });
            }
        }, {
            key: "VERSION",
            get: function() {
                return "4.0.0";
            }
        }, {
            key: "Default",
            get: function() {
                return n;
            }
        } ]), i;
    }();
    return t(window).on(o.LOAD_DATA_API, function() {
        for (var e = t.makeArray(t(r.DATA_SPY)), i = e.length; i--; ) {
            var n = t(e[i]);
            h._jQueryInterface.call(n, n.data());
        }
    }), t.fn[e] = h._jQueryInterface, t.fn[e].Constructor = h, t.fn[e].noConflict = function() {
        return t.fn[e] = i, h._jQueryInterface;
    }, h;
}(jQuery), _createClass = function() {
    function t(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
            Object.defineProperty(t, n.key, n);
        }
    }
    return function(e, i, n) {
        return i && t(e.prototype, i), n && t(e, n), e;
    };
}(), Tab = function(t) {
    var e = t.fn.tab, i = {
        HIDE: "hide.bs.tab",
        HIDDEN: "hidden.bs.tab",
        SHOW: "show.bs.tab",
        SHOWN: "shown.bs.tab",
        CLICK_DATA_API: "click.bs.tab.data-api"
    }, n = {
        DROPDOWN_MENU: "dropdown-menu",
        ACTIVE: "active",
        FADE: "fade",
        IN: "in"
    }, s = {
        A: "a",
        LI: "li",
        DROPDOWN: ".dropdown",
        UL: "ul:not(.dropdown-menu)",
        FADE_CHILD: "> .nav-item .fade, > .fade",
        ACTIVE: ".active",
        ACTIVE_CHILD: "> .nav-item > .active, > .active",
        DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"]',
        DROPDOWN_TOGGLE: ".dropdown-toggle",
        DROPDOWN_ACTIVE_CHILD: "> .dropdown-menu .active"
    }, o = function() {
        function e(t) {
            _classCallCheck(this, e), this._element = t;
        }
        return _createClass(e, [ {
            key: "show",
            value: function() {
                var e = this;
                if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE || !t(this._element).hasClass(n.ACTIVE)) {
                    var o = void 0, a = void 0, r = t(this._element).closest(s.UL)[0], l = Util.getSelectorFromElement(this._element);
                    r && (a = t.makeArray(t(r).find(s.ACTIVE)), a = a[a.length - 1]);
                    var h = t.Event(i.HIDE, {
                        relatedTarget: this._element
                    }), c = t.Event(i.SHOW, {
                        relatedTarget: a
                    });
                    if (a && t(a).trigger(h), t(this._element).trigger(c), !c.isDefaultPrevented() && !h.isDefaultPrevented()) {
                        l && (o = t(l)[0]), this._activate(this._element, r);
                        var u = function() {
                            var n = t.Event(i.HIDDEN, {
                                relatedTarget: e._element
                            }), s = t.Event(i.SHOWN, {
                                relatedTarget: a
                            });
                            t(a).trigger(n), t(e._element).trigger(s);
                        };
                        o ? this._activate(o, o.parentNode, u) : u();
                    }
                }
            }
        }, {
            key: "dispose",
            value: function() {
                t.removeClass(this._element, "bs.tab"), this._element = null;
            }
        }, {
            key: "_activate",
            value: function(e, i, o) {
                var a = t(i).find(s.ACTIVE_CHILD)[0], r = o && Util.supportsTransitionEnd() && (a && t(a).hasClass(n.FADE) || Boolean(t(i).find(s.FADE_CHILD)[0])), l = t.proxy(this._transitionComplete, this, e, a, r, o);
                a && r ? t(a).one(Util.TRANSITION_END, l).emulateTransitionEnd(150) : l(), a && t(a).removeClass(n.IN);
            }
        }, {
            key: "_transitionComplete",
            value: function(e, i, o, a) {
                if (i) {
                    t(i).removeClass(n.ACTIVE);
                    var r = t(i).find(s.DROPDOWN_ACTIVE_CHILD)[0];
                    r && t(r).removeClass(n.ACTIVE), i.setAttribute("aria-expanded", !1);
                }
                if (t(e).addClass(n.ACTIVE), e.setAttribute("aria-expanded", !0), o ? (Util.reflow(e), 
                t(e).addClass(n.IN)) : t(e).removeClass(n.FADE), e.parentNode && t(e.parentNode).hasClass(n.DROPDOWN_MENU)) {
                    var l = t(e).closest(s.DROPDOWN)[0];
                    l && t(l).find(s.DROPDOWN_TOGGLE).addClass(n.ACTIVE), e.setAttribute("aria-expanded", !0);
                }
                a && a();
            }
        } ], [ {
            key: "_jQueryInterface",
            value: function(i) {
                return this.each(function() {
                    var n = t(this), s = n.data("bs.tab");
                    s || (s = s = new e(this), n.data("bs.tab", s)), "string" == typeof i && s[i]();
                });
            }
        }, {
            key: "VERSION",
            get: function() {
                return "4.0.0";
            }
        } ]), e;
    }();
    return t(document).on(i.CLICK_DATA_API, s.DATA_TOGGLE, function(e) {
        e.preventDefault(), o._jQueryInterface.call(t(this), "show");
    }), t.fn.tab = o._jQueryInterface, t.fn.tab.Constructor = o, t.fn.tab.noConflict = function() {
        return t.fn.tab = e, o._jQueryInterface;
    }, o;
}(jQuery), _createClass = function() {
    function t(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
            Object.defineProperty(t, n.key, n);
        }
    }
    return function(e, i, n) {
        return i && t(e.prototype, i), n && t(e, n), e;
    };
}(), Tooltip = function(t) {
    var e = "tooltip", i = ".bs.tooltip", n = t.fn[e], s = {
        animation: !0,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        selector: !1,
        placement: "top",
        offset: "0 0",
        constraints: []
    }, o = {
        animation: "boolean",
        template: "string",
        title: "(string|function)",
        trigger: "string",
        delay: "(number|object)",
        html: "boolean",
        selector: "(string|boolean)",
        placement: "(string|function)",
        offset: "string",
        constraints: "array"
    }, a = {
        TOP: "bottom center",
        RIGHT: "middle left",
        BOTTOM: "top center",
        LEFT: "middle right"
    }, r = {
        IN: "in",
        OUT: "out"
    }, l = {
        HIDE: "hide" + i,
        HIDDEN: "hidden" + i,
        SHOW: "show" + i,
        SHOWN: "shown" + i,
        INSERTED: "inserted" + i,
        CLICK: "click" + i,
        FOCUSIN: "focusin" + i,
        FOCUSOUT: "focusout" + i,
        MOUSEENTER: "mouseenter" + i,
        MOUSELEAVE: "mouseleave" + i
    }, h = {
        FADE: "fade",
        IN: "in"
    }, c = {
        TOOLTIP: ".tooltip",
        TOOLTIP_INNER: ".tooltip-inner"
    }, u = {
        element: !1,
        enabled: !1
    }, d = {
        HOVER: "hover",
        FOCUS: "focus",
        CLICK: "click",
        MANUAL: "manual"
    }, f = function() {
        function n(t, e) {
            _classCallCheck(this, n), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", 
            this._activeTrigger = {}, this._tether = null, this.element = t, this.config = this._getConfig(e), 
            this.tip = null, this._setListeners();
        }
        return _createClass(n, [ {
            key: "enable",
            value: function() {
                this._isEnabled = !0;
            }
        }, {
            key: "disable",
            value: function() {
                this._isEnabled = !1;
            }
        }, {
            key: "toggleEnabled",
            value: function() {
                this._isEnabled = !this._isEnabled;
            }
        }, {
            key: "toggle",
            value: function(e) {
                if (e) {
                    var i = this.constructor.DATA_KEY, n = t(e.currentTarget).data(i);
                    n || (n = new this.constructor(e.currentTarget, this._getDelegateConfig()), t(e.currentTarget).data(i, n)), 
                    n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n);
                } else {
                    if (t(this.getTipElement()).hasClass(h.IN)) return void this._leave(null, this);
                    this._enter(null, this);
                }
            }
        }, {
            key: "dispose",
            value: function() {
                clearTimeout(this._timeout), this.cleanupTether(), t.removeData(this.element, this.constructor.DATA_KEY), 
                t(this.element).off(this.constructor.EVENT_KEY), this.tip && t(this.tip).remove(), 
                this._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, 
                this._tether = null, this.element = null, this.config = null, this.tip = null;
            }
        }, {
            key: "show",
            value: function() {
                var e = this, i = t.Event(this.constructor.Event.SHOW);
                if (this.isWithContent() && this._isEnabled) {
                    t(this.element).trigger(i);
                    var s = t.contains(this.element.ownerDocument.documentElement, this.element);
                    if (i.isDefaultPrevented() || !s) return;
                    var o = this.getTipElement(), a = Util.getUID(this.constructor.NAME);
                    o.setAttribute("id", a), this.element.setAttribute("aria-describedby", a), this.setContent(), 
                    this.config.animation && t(o).addClass(h.FADE);
                    var l = "function" == typeof this.config.placement ? this.config.placement.call(this, o, this.element) : this.config.placement, c = this._getAttachment(l);
                    t(o).data(this.constructor.DATA_KEY, this).appendTo(document.body), t(this.element).trigger(this.constructor.Event.INSERTED), 
                    this._tether = new Tether({
                        attachment: c,
                        element: o,
                        target: this.element,
                        classes: u,
                        classPrefix: "bs-tether",
                        offset: this.config.offset,
                        constraints: this.config.constraints
                    }), Util.reflow(o), this._tether.position(), t(o).addClass(h.IN);
                    var d = function() {
                        var i = e._hoverState;
                        e._hoverState = null, t(e.element).trigger(e.constructor.Event.SHOWN), i === r.OUT && e._leave(null, e);
                    };
                    if (Util.supportsTransitionEnd() && t(this.tip).hasClass(h.FADE)) return void t(this.tip).one(Util.TRANSITION_END, d).emulateTransitionEnd(n._TRANSITION_DURATION);
                    d();
                }
            }
        }, {
            key: "hide",
            value: function(e) {
                var i = this, n = this.getTipElement(), s = t.Event(this.constructor.Event.HIDE), o = function() {
                    i._hoverState !== r.IN && n.parentNode && n.parentNode.removeChild(n), i.element.removeAttribute("aria-describedby"), 
                    t(i.element).trigger(i.constructor.Event.HIDDEN), i.cleanupTether(), e && e();
                };
                t(this.element).trigger(s), s.isDefaultPrevented() || (t(n).removeClass(h.IN), Util.supportsTransitionEnd() && t(this.tip).hasClass(h.FADE) ? t(n).one(Util.TRANSITION_END, o).emulateTransitionEnd(150) : o(), 
                this._hoverState = "");
            }
        }, {
            key: "isWithContent",
            value: function() {
                return Boolean(this.getTitle());
            }
        }, {
            key: "getTipElement",
            value: function() {
                return this.tip = this.tip || t(this.config.template)[0];
            }
        }, {
            key: "setContent",
            value: function() {
                var e = this.getTipElement(), i = this.getTitle(), n = this.config.html ? "innerHTML" : "innerText";
                t(e).find(c.TOOLTIP_INNER)[0][n] = i, t(e).removeClass(h.FADE).removeClass(h.IN), 
                this.cleanupTether();
            }
        }, {
            key: "getTitle",
            value: function() {
                var t = this.element.getAttribute("data-original-title");
                return t || (t = "function" == typeof this.config.title ? this.config.title.call(this.element) : this.config.title), 
                t;
            }
        }, {
            key: "cleanupTether",
            value: function() {
                this._tether && (this._tether.destroy(), t(this.element).removeClass(this._removeTetherClasses), 
                t(this.tip).removeClass(this._removeTetherClasses));
            }
        }, {
            key: "_getAttachment",
            value: function(t) {
                return a[t.toUpperCase()];
            }
        }, {
            key: "_setListeners",
            value: function() {
                var e = this;
                this.config.trigger.split(" ").forEach(function(i) {
                    if ("click" === i) t(e.element).on(e.constructor.Event.CLICK, e.config.selector, t.proxy(e.toggle, e)); else if (i !== d.MANUAL) {
                        var n = i === d.HOVER ? e.constructor.Event.MOUSEENTER : e.constructor.Event.FOCUSIN, s = i === d.HOVER ? e.constructor.Event.MOUSELEAVE : e.constructor.Event.FOCUSOUT;
                        t(e.element).on(n, e.config.selector, t.proxy(e._enter, e)).on(s, e.config.selector, t.proxy(e._leave, e));
                    }
                }), this.config.selector ? this.config = t.extend({}, this.config, {
                    trigger: "manual",
                    selector: ""
                }) : this._fixTitle();
            }
        }, {
            key: "_removeTetherClasses",
            value: function(t, e) {
                return ((e.baseVal || e).match(new RegExp("(^|\\s)bs-tether-\\S+", "g")) || []).join(" ");
            }
        }, {
            key: "_fixTitle",
            value: function() {
                var t = typeof this.element.getAttribute("data-original-title");
                (this.element.getAttribute("title") || "string" !== t) && (this.element.setAttribute("data-original-title", this.element.getAttribute("title") || ""), 
                this.element.setAttribute("title", ""));
            }
        }, {
            key: "_enter",
            value: function(e, i) {
                var n = this.constructor.DATA_KEY;
                return (i = i || t(e.currentTarget).data(n)) || (i = new this.constructor(e.currentTarget, this._getDelegateConfig()), 
                t(e.currentTarget).data(n, i)), e && (i._activeTrigger["focusin" === e.type ? d.FOCUS : d.HOVER] = !0), 
                t(i.getTipElement()).hasClass(h.IN) || i._hoverState === r.IN ? void (i._hoverState = r.IN) : (clearTimeout(i._timeout), 
                i._hoverState = r.IN, i.config.delay && i.config.delay.show ? void (i._timeout = setTimeout(function() {
                    i._hoverState === r.IN && i.show();
                }, i.config.delay.show)) : void i.show());
            }
        }, {
            key: "_leave",
            value: function(e, i) {
                var n = this.constructor.DATA_KEY;
                if ((i = i || t(e.currentTarget).data(n)) || (i = new this.constructor(e.currentTarget, this._getDelegateConfig()), 
                t(e.currentTarget).data(n, i)), e && (i._activeTrigger["focusout" === e.type ? d.FOCUS : d.HOVER] = !1), 
                !i._isWithActiveTrigger()) {
                    if (clearTimeout(i._timeout), i._hoverState = r.OUT, !i.config.delay || !i.config.delay.hide) return void i.hide();
                    i._timeout = setTimeout(function() {
                        i._hoverState === r.OUT && i.hide();
                    }, i.config.delay.hide);
                }
            }
        }, {
            key: "_isWithActiveTrigger",
            value: function() {
                for (var t in this._activeTrigger) if (this._activeTrigger[t]) return !0;
                return !1;
            }
        }, {
            key: "_getConfig",
            value: function(i) {
                return (i = t.extend({}, this.constructor.Default, t(this.element).data(), i)).delay && "number" == typeof i.delay && (i.delay = {
                    show: i.delay,
                    hide: i.delay
                }), Util.typeCheckConfig(e, i, this.constructor.DefaultType), i;
            }
        }, {
            key: "_getDelegateConfig",
            value: function() {
                var t = {};
                if (this.config) for (var e in this.config) this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]);
                return t;
            }
        } ], [ {
            key: "_jQueryInterface",
            value: function(e) {
                return this.each(function() {
                    var i = t(this).data("bs.tooltip"), s = "object" == typeof e ? e : null;
                    !i && /destroy|hide/.test(e) || (i || (i = new n(this, s), t(this).data("bs.tooltip", i)), 
                    "string" == typeof e && i[e]());
                });
            }
        }, {
            key: "VERSION",
            get: function() {
                return "4.0.0";
            }
        }, {
            key: "Default",
            get: function() {
                return s;
            }
        }, {
            key: "NAME",
            get: function() {
                return e;
            }
        }, {
            key: "DATA_KEY",
            get: function() {
                return "bs.tooltip";
            }
        }, {
            key: "Event",
            get: function() {
                return l;
            }
        }, {
            key: "EVENT_KEY",
            get: function() {
                return i;
            }
        }, {
            key: "DefaultType",
            get: function() {
                return o;
            }
        } ]), n;
    }();
    return t.fn[e] = f._jQueryInterface, t.fn[e].Constructor = f, t.fn[e].noConflict = function() {
        return t.fn[e] = n, f._jQueryInterface;
    }, f;
}(jQuery), _createClass = function() {
    function t(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
            Object.defineProperty(t, n.key, n);
        }
    }
    return function(e, i, n) {
        return i && t(e.prototype, i), n && t(e, n), e;
    };
}(), _get = function(t, e, i) {
    for (var n = !0; n; ) {
        var s = t, o = e, a = i;
        r = h = l = void 0, n = !1, null === s && (s = Function.prototype);
        var r = Object.getOwnPropertyDescriptor(s, o);
        if (void 0 !== r) {
            if ("value" in r) return r.value;
            var l = r.get;
            if (void 0 === l) return;
            return l.call(a);
        }
        var h = Object.getPrototypeOf(s);
        if (null === h) return;
        t = h, e = o, i = a, n = !0;
    }
}, Popover = function(t) {
    var e = "popover", i = ".bs.popover", n = t.fn[e], s = t.extend({}, Tooltip.Default, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), o = t.extend({}, Tooltip.DefaultType, {
        content: "(string|function)"
    }), a = {
        FADE: "fade",
        IN: "in"
    }, r = {
        TITLE: ".popover-title",
        CONTENT: ".popover-content",
        ARROW: ".popover-arrow"
    }, l = {
        HIDE: "hide" + i,
        HIDDEN: "hidden" + i,
        SHOW: "show" + i,
        SHOWN: "shown" + i,
        INSERTED: "inserted" + i,
        CLICK: "click" + i,
        FOCUSIN: "focusin" + i,
        FOCUSOUT: "focusout" + i,
        MOUSEENTER: "mouseenter" + i,
        MOUSELEAVE: "mouseleave" + i
    }, h = function(n) {
        function h() {
            _classCallCheck(this, h), _get(Object.getPrototypeOf(h.prototype), "constructor", this).apply(this, arguments);
        }
        return _inherits(h, n), _createClass(h, [ {
            key: "isWithContent",
            value: function() {
                return this.getTitle() || this._getContent();
            }
        }, {
            key: "getTipElement",
            value: function() {
                return this.tip = this.tip || t(this.config.template)[0];
            }
        }, {
            key: "setContent",
            value: function() {
                var e = this.getTipElement(), i = this.getTitle(), n = this._getContent(), s = t(e).find(r.TITLE)[0];
                s && (s[this.config.html ? "innerHTML" : "innerText"] = i), t(e).find(r.CONTENT).children().detach().end()[this.config.html ? "string" == typeof n ? "html" : "append" : "text"](n), 
                t(e).removeClass(a.FADE).removeClass(a.IN), this.cleanupTether();
            }
        }, {
            key: "_getContent",
            value: function() {
                return this.element.getAttribute("data-content") || ("function" == typeof this.config.content ? this.config.content.call(this.element) : this.config.content);
            }
        } ], [ {
            key: "_jQueryInterface",
            value: function(e) {
                return this.each(function() {
                    var i = t(this).data("bs.popover"), n = "object" == typeof e ? e : null;
                    !i && /destroy|hide/.test(e) || (i || (i = new h(this, n), t(this).data("bs.popover", i)), 
                    "string" == typeof e && i[e]());
                });
            }
        }, {
            key: "VERSION",
            get: function() {
                return "4.0.0";
            }
        }, {
            key: "Default",
            get: function() {
                return s;
            }
        }, {
            key: "NAME",
            get: function() {
                return e;
            }
        }, {
            key: "DATA_KEY",
            get: function() {
                return "bs.popover";
            }
        }, {
            key: "Event",
            get: function() {
                return l;
            }
        }, {
            key: "EVENT_KEY",
            get: function() {
                return i;
            }
        }, {
            key: "DefaultType",
            get: function() {
                return o;
            }
        } ]), h;
    }(Tooltip);
    return t.fn[e] = h._jQueryInterface, t.fn[e].Constructor = h, t.fn[e].noConflict = function() {
        return t.fn[e] = n, h._jQueryInterface;
    }, h;
}(jQuery);

(function() {
    var t = this, e = t.Chart, i = function(t) {
        this.canvas = t.canvas, this.ctx = t;
        var e = function(t, e) {
            return t["offset" + e] ? t["offset" + e] : document.defaultView.getComputedStyle(t).getPropertyValue(e);
        }, i = this.width = e(t.canvas, "Width"), s = this.height = e(t.canvas, "Height");
        t.canvas.width = i, t.canvas.height = s;
        var i = this.width = t.canvas.width, s = this.height = t.canvas.height;
        return this.aspectRatio = this.width / this.height, n.retinaScale(this), this;
    };
    i.defaults = {
        global: {
            animation: !0,
            animationSteps: 60,
            animationEasing: "easeOutQuart",
            showScale: !0,
            scaleOverride: !1,
            scaleSteps: null,
            scaleStepWidth: null,
            scaleStartValue: null,
            scaleLineColor: "rgba(0,0,0,.1)",
            scaleLineWidth: 1,
            scaleShowLabels: !0,
            scaleLabel: "<%=value%>",
            scaleIntegersOnly: !0,
            scaleBeginAtZero: !1,
            scaleFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            scaleFontSize: 12,
            scaleFontStyle: "normal",
            scaleFontColor: "#666",
            responsive: !1,
            maintainAspectRatio: !0,
            showTooltips: !0,
            customTooltips: !1,
            tooltipEvents: [ "mousemove", "touchstart", "touchmove", "mouseout" ],
            tooltipFillColor: "rgba(0,0,0,0.8)",
            tooltipFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            tooltipFontSize: 14,
            tooltipFontStyle: "normal",
            tooltipFontColor: "#fff",
            tooltipTitleFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            tooltipTitleFontSize: 14,
            tooltipTitleFontStyle: "bold",
            tooltipTitleFontColor: "#fff",
            tooltipYPadding: 6,
            tooltipXPadding: 6,
            tooltipCaretSize: 8,
            tooltipCornerRadius: 6,
            tooltipXOffset: 10,
            tooltipTemplate: "<%if (label){%><%=label%>: <%}%><%= value %>",
            multiTooltipTemplate: "<%= value %>",
            multiTooltipKeyBackground: "#fff",
            onAnimationProgress: function() {},
            onAnimationComplete: function() {}
        }
    }, i.types = {};
    var n = i.helpers = {}, s = n.each = function(t, e, i) {
        var n = Array.prototype.slice.call(arguments, 3);
        if (t) if (t.length === +t.length) {
            var s;
            for (s = 0; s < t.length; s++) e.apply(i, [ t[s], s ].concat(n));
        } else for (var o in t) e.apply(i, [ t[o], o ].concat(n));
    }, o = n.clone = function(t) {
        var e = {};
        return s(t, function(i, n) {
            t.hasOwnProperty(n) && (e[n] = i);
        }), e;
    }, a = n.extend = function(t) {
        return s(Array.prototype.slice.call(arguments, 1), function(e) {
            s(e, function(i, n) {
                e.hasOwnProperty(n) && (t[n] = i);
            });
        }), t;
    }, r = n.merge = function(t, e) {
        var i = Array.prototype.slice.call(arguments, 0);
        return i.unshift({}), a.apply(null, i);
    }, l = n.indexOf = function(t, e) {
        if (Array.prototype.indexOf) return t.indexOf(e);
        for (var i = 0; i < t.length; i++) if (t[i] === e) return i;
        return -1;
    }, h = (n.where = function(t, e) {
        var i = [];
        return n.each(t, function(t) {
            e(t) && i.push(t);
        }), i;
    }, n.findNextWhere = function(t, e, i) {
        i || (i = -1);
        for (var n = i + 1; n < t.length; n++) {
            var s = t[n];
            if (e(s)) return s;
        }
    }, n.findPreviousWhere = function(t, e, i) {
        i || (i = t.length);
        for (var n = i - 1; n >= 0; n--) {
            var s = t[n];
            if (e(s)) return s;
        }
    }, n.inherits = function(t) {
        var e = this, i = t && t.hasOwnProperty("constructor") ? t.constructor : function() {
            return e.apply(this, arguments);
        }, n = function() {
            this.constructor = i;
        };
        return n.prototype = e.prototype, i.prototype = new n(), i.extend = h, t && a(i.prototype, t), 
        i.__super__ = e.prototype, i;
    }), c = n.noop = function() {}, u = n.uid = function() {
        var t = 0;
        return function() {
            return "chart-" + t++;
        };
    }(), d = n.warn = function(t) {
        window.console && "function" == typeof window.console.warn && console.warn(t);
    }, f = n.amd = "function" == typeof define && define.amd, p = n.isNumber = function(t) {
        return !isNaN(parseFloat(t)) && isFinite(t);
    }, g = n.max = function(t) {
        return Math.max.apply(Math, t);
    }, v = n.min = function(t) {
        return Math.min.apply(Math, t);
    }, m = (n.cap = function(t, e, i) {
        if (p(e)) {
            if (t > e) return e;
        } else if (p(i) && t < i) return i;
        return t;
    }, n.getDecimalPlaces = function(t) {
        return t % 1 != 0 && p(t) ? t.toString().split(".")[1].length : 0;
    }), y = n.radians = function(t) {
        return t * (Math.PI / 180);
    }, _ = (n.getAngleFromPoint = function(t, e) {
        var i = e.x - t.x, n = e.y - t.y, s = Math.sqrt(i * i + n * n), o = 2 * Math.PI + Math.atan2(n, i);
        return i < 0 && n < 0 && (o += 2 * Math.PI), {
            angle: o,
            distance: s
        };
    }, n.aliasPixel = function(t) {
        return t % 2 == 0 ? 0 : .5;
    }), C = (n.splineCurve = function(t, e, i, n) {
        var s = Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)), o = Math.sqrt(Math.pow(i.x - e.x, 2) + Math.pow(i.y - e.y, 2)), a = n * s / (s + o), r = n * o / (s + o);
        return {
            inner: {
                x: e.x - a * (i.x - t.x),
                y: e.y - a * (i.y - t.y)
            },
            outer: {
                x: e.x + r * (i.x - t.x),
                y: e.y + r * (i.y - t.y)
            }
        };
    }, n.calculateOrderOfMagnitude = function(t) {
        return Math.floor(Math.log(t) / Math.LN10);
    }), w = (n.calculateScaleRange = function(t, e, i, n, s) {
        var o = Math.floor(e / (1.5 * i)), a = 2 >= o, r = g(t), l = v(t);
        r === l && (r += .5, l >= .5 && !n ? l -= .5 : r += .5);
        for (var h = Math.abs(r - l), c = C(h), u = Math.ceil(r / (1 * Math.pow(10, c))) * Math.pow(10, c), d = n ? 0 : Math.floor(l / (1 * Math.pow(10, c))) * Math.pow(10, c), f = u - d, p = Math.pow(10, c), m = Math.round(f / p); (m > o || 2 * m < o) && !a; ) if (m > o) p *= 2, 
        (m = Math.round(f / p)) % 1 != 0 && (a = !0); else if (s && c >= 0) {
            if (p / 2 % 1 != 0) break;
            p /= 2, m = Math.round(f / p);
        } else p /= 2, m = Math.round(f / p);
        return a && (p = f / (m = 2)), {
            steps: m,
            stepValue: p,
            min: d,
            max: d + m * p
        };
    }, n.template = function(t, e) {
        if (t instanceof Function) return t(e);
        var i = {};
        return function(t, e) {
            var n = /\W/.test(t) ? new Function("obj", "var p=[],print=function(){p.push.apply(p,arguments);};with(obj){p.push('" + t.replace(/[\r\t\n]/g, " ").split("<%").join("\t").replace(/((^|%>)[^\t]*)'/g, "$1\r").replace(/\t=(.*?)%>/g, "',$1,'").split("\t").join("');").split("%>").join("p.push('").split("\r").join("\\'") + "');}return p.join('');") : i[t] = i[t];
            return e ? n(e) : n;
        }(t, e);
    }), b = (n.generateLabels = function(t, e, i, n) {
        var o = new Array(e);
        return labelTemplateString && s(o, function(e, s) {
            o[s] = w(t, {
                value: i + n * (s + 1)
            });
        }), o;
    }, n.easingEffects = {
        linear: function(t) {
            return t;
        },
        easeInQuad: function(t) {
            return t * t;
        },
        easeOutQuad: function(t) {
            return -1 * t * (t - 2);
        },
        easeInOutQuad: function(t) {
            return (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1);
        },
        easeInCubic: function(t) {
            return t * t * t;
        },
        easeOutCubic: function(t) {
            return 1 * ((t = t / 1 - 1) * t * t + 1);
        },
        easeInOutCubic: function(t) {
            return (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2);
        },
        easeInQuart: function(t) {
            return t * t * t * t;
        },
        easeOutQuart: function(t) {
            return -1 * ((t = t / 1 - 1) * t * t * t - 1);
        },
        easeInOutQuart: function(t) {
            return (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2);
        },
        easeInQuint: function(t) {
            return 1 * (t /= 1) * t * t * t * t;
        },
        easeOutQuint: function(t) {
            return 1 * ((t = t / 1 - 1) * t * t * t * t + 1);
        },
        easeInOutQuint: function(t) {
            return (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2);
        },
        easeInSine: function(t) {
            return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;
        },
        easeOutSine: function(t) {
            return 1 * Math.sin(t / 1 * (Math.PI / 2));
        },
        easeInOutSine: function(t) {
            return -.5 * (Math.cos(Math.PI * t / 1) - 1);
        },
        easeInExpo: function(t) {
            return 0 === t ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));
        },
        easeOutExpo: function(t) {
            return 1 === t ? 1 : 1 * (1 - Math.pow(2, -10 * t / 1));
        },
        easeInOutExpo: function(t) {
            return 0 === t ? 0 : 1 === t ? 1 : (t /= .5) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * --t));
        },
        easeInCirc: function(t) {
            return t >= 1 ? t : -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);
        },
        easeOutCirc: function(t) {
            return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);
        },
        easeInOutCirc: function(t) {
            return (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
        },
        easeInElastic: function(t) {
            var e = 1.70158, i = 0, n = 1;
            return 0 === t ? 0 : 1 == (t /= 1) ? 1 : (i || (i = .3), n < Math.abs(1) ? (n = 1, 
            e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), -n * Math.pow(2, 10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / i));
        },
        easeOutElastic: function(t) {
            var e = 1.70158, i = 0, n = 1;
            return 0 === t ? 0 : 1 == (t /= 1) ? 1 : (i || (i = .3), n < Math.abs(1) ? (n = 1, 
            e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), n * Math.pow(2, -10 * t) * Math.sin((1 * t - e) * (2 * Math.PI) / i) + 1);
        },
        easeInOutElastic: function(t) {
            var e = 1.70158, i = 0, n = 1;
            return 0 === t ? 0 : 2 == (t /= .5) ? 1 : (i || (i = .3 * 1.5 * 1), n < Math.abs(1) ? (n = 1, 
            e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), t < 1 ? n * Math.pow(2, 10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / i) * -.5 : n * Math.pow(2, -10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / i) * .5 + 1);
        },
        easeInBack: function(t) {
            var e = 1.70158;
            return 1 * (t /= 1) * t * ((e + 1) * t - e);
        },
        easeOutBack: function(t) {
            var e = 1.70158;
            return 1 * ((t = t / 1 - 1) * t * ((e + 1) * t + e) + 1);
        },
        easeInOutBack: function(t) {
            var e = 1.70158;
            return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2);
        },
        easeInBounce: function(t) {
            return 1 - b.easeOutBounce(1 - t);
        },
        easeOutBounce: function(t) {
            return (t /= 1) < 1 / 2.75 ? 7.5625 * t * t * 1 : t < 2 / 2.75 ? 1 * (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 * (7.5625 * (t -= 2.625 / 2.75) * t + .984375);
        },
        easeInOutBounce: function(t) {
            return t < .5 ? .5 * b.easeInBounce(2 * t) : .5 * b.easeOutBounce(2 * t - 1) + .5;
        }
    }), S = n.requestAnimFrame = function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t) {
            return window.setTimeout(t, 1e3 / 60);
        };
    }(), E = n.cancelAnimFrame = function() {
        return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function(t) {
            return window.clearTimeout(t, 1e3 / 60);
        };
    }(), T = (n.animationLoop = function(t, e, i, n, s, o) {
        var a = 0, r = b[i] || b.linear, l = function() {
            var i = ++a / e, h = r(i);
            t.call(o, h, i, a), n.call(o, h, i), a < e ? o.animationFrame = S(l) : s.apply(o);
        };
        S(l);
    }, n.getRelativePosition = function(t) {
        var e, i, n = t.originalEvent || t, s = (t.currentTarget || t.srcElement).getBoundingClientRect();
        return n.touches ? (e = n.touches[0].clientX - s.left, i = n.touches[0].clientY - s.top) : (e = n.clientX - s.left, 
        i = n.clientY - s.top), {
            x: e,
            y: i
        };
    }, n.addEvent = function(t, e, i) {
        t.addEventListener ? t.addEventListener(e, i) : t.attachEvent ? t.attachEvent("on" + e, i) : t["on" + e] = i;
    }), A = n.removeEvent = function(t, e, i) {
        t.removeEventListener ? t.removeEventListener(e, i, !1) : t.detachEvent ? t.detachEvent("on" + e, i) : t["on" + e] = c;
    }, I = (n.bindEvents = function(t, e, i) {
        t.events || (t.events = {}), s(e, function(e) {
            t.events[e] = function() {
                i.apply(t, arguments);
            }, T(t.chart.canvas, e, t.events[e]);
        });
    }, n.unbindEvents = function(t, e) {
        s(e, function(e, i) {
            A(t.chart.canvas, i, e);
        });
    }), x = n.getMaximumWidth = function(t) {
        return t.parentNode.clientWidth;
    }, k = n.getMaximumHeight = function(t) {
        return t.parentNode.clientHeight;
    }, P = (n.getMaximumSize = n.getMaximumWidth, n.retinaScale = function(t) {
        var e = t.ctx, i = t.canvas.width, n = t.canvas.height;
        window.devicePixelRatio && (e.canvas.style.width = i + "px", e.canvas.style.height = n + "px", 
        e.canvas.height = n * window.devicePixelRatio, e.canvas.width = i * window.devicePixelRatio, 
        e.scale(window.devicePixelRatio, window.devicePixelRatio));
    }), O = n.clear = function(t) {
        t.ctx.clearRect(0, 0, t.width, t.height);
    }, L = n.fontString = function(t, e, i) {
        return e + " " + t + "px " + i;
    }, D = n.longestText = function(t, e, i) {
        t.font = e;
        var n = 0;
        return s(i, function(e) {
            var i = t.measureText(e).width;
            n = i > n ? i : n;
        }), n;
    }, N = n.drawRoundedRectangle = function(t, e, i, n, s, o) {
        t.beginPath(), t.moveTo(e + o, i), t.lineTo(e + n - o, i), t.quadraticCurveTo(e + n, i, e + n, i + o), 
        t.lineTo(e + n, i + s - o), t.quadraticCurveTo(e + n, i + s, e + n - o, i + s), 
        t.lineTo(e + o, i + s), t.quadraticCurveTo(e, i + s, e, i + s - o), t.lineTo(e, i + o), 
        t.quadraticCurveTo(e, i, e + o, i), t.closePath();
    };
    i.instances = {}, a((i.Type = function(t, e, n) {
        this.options = e, this.chart = n, this.id = u(), i.instances[this.id] = this, e.responsive && this.resize(), 
        this.initialize.call(this, t);
    }).prototype, {
        initialize: function() {
            return this;
        },
        clear: function() {
            return O(this.chart), this;
        },
        stop: function() {
            return E(this.animationFrame), this;
        },
        resize: function(t) {
            this.stop();
            var e = this.chart.canvas, i = x(this.chart.canvas), n = this.options.maintainAspectRatio ? i / this.chart.aspectRatio : k(this.chart.canvas);
            return e.width = this.chart.width = i, e.height = this.chart.height = n, P(this.chart), 
            "function" == typeof t && t.apply(this, Array.prototype.slice.call(arguments, 1)), 
            this;
        },
        reflow: c,
        render: function(t) {
            return t && this.reflow(), this.options.animation && !t ? n.animationLoop(this.draw, this.options.animationSteps, this.options.animationEasing, this.options.onAnimationProgress, this.options.onAnimationComplete, this) : (this.draw(), 
            this.options.onAnimationComplete.call(this)), this;
        },
        generateLegend: function() {
            return w(this.options.legendTemplate, this);
        },
        destroy: function() {
            this.clear(), I(this, this.events);
            var t = this.chart.canvas;
            t.width = this.chart.width, t.height = this.chart.height, t.style.removeProperty ? (t.style.removeProperty("width"), 
            t.style.removeProperty("height")) : (t.style.removeAttribute("width"), t.style.removeAttribute("height")), 
            delete i.instances[this.id];
        },
        showTooltip: function(t, e) {
            if (void 0 === this.activeElements && (this.activeElements = []), function(t) {
                var e = !1;
                return t.length !== this.activeElements.length ? e = !0 : (s(t, function(t, i) {
                    t !== this.activeElements[i] && (e = !0);
                }, this), e);
            }.call(this, t) || e) {
                if (this.activeElements = t, this.draw(), this.options.customTooltips && this.options.customTooltips(!1), 
                t.length > 0) if (this.datasets && this.datasets.length > 1) {
                    for (var o, a, r = this.datasets.length - 1; r >= 0 && (o = this.datasets[r].points || this.datasets[r].bars || this.datasets[r].segments, 
                    -1 === (a = l(o, t[0]))); r--) ;
                    var h = [], c = [], u = function(t) {
                        var e, i, s, o, r, l = [], u = [], d = [];
                        return n.each(this.datasets, function(t) {
                            (e = t.points || t.bars || t.segments)[a] && e[a].hasValue() && l.push(e[a]);
                        }), n.each(l, function(t) {
                            u.push(t.x), d.push(t.y), h.push(n.template(this.options.multiTooltipTemplate, t)), 
                            c.push({
                                fill: t._saved.fillColor || t.fillColor,
                                stroke: t._saved.strokeColor || t.strokeColor
                            });
                        }, this), r = v(d), s = g(d), o = v(u), i = g(u), {
                            x: o > this.chart.width / 2 ? o : i,
                            y: (r + s) / 2
                        };
                    }.call(this, a);
                    new i.MultiTooltip({
                        x: u.x,
                        y: u.y,
                        xPadding: this.options.tooltipXPadding,
                        yPadding: this.options.tooltipYPadding,
                        xOffset: this.options.tooltipXOffset,
                        fillColor: this.options.tooltipFillColor,
                        textColor: this.options.tooltipFontColor,
                        fontFamily: this.options.tooltipFontFamily,
                        fontStyle: this.options.tooltipFontStyle,
                        fontSize: this.options.tooltipFontSize,
                        titleTextColor: this.options.tooltipTitleFontColor,
                        titleFontFamily: this.options.tooltipTitleFontFamily,
                        titleFontStyle: this.options.tooltipTitleFontStyle,
                        titleFontSize: this.options.tooltipTitleFontSize,
                        cornerRadius: this.options.tooltipCornerRadius,
                        labels: h,
                        legendColors: c,
                        legendColorBackground: this.options.multiTooltipKeyBackground,
                        title: t[0].label,
                        chart: this.chart,
                        ctx: this.chart.ctx,
                        custom: this.options.customTooltips
                    }).draw();
                } else s(t, function(t) {
                    var e = t.tooltipPosition();
                    new i.Tooltip({
                        x: Math.round(e.x),
                        y: Math.round(e.y),
                        xPadding: this.options.tooltipXPadding,
                        yPadding: this.options.tooltipYPadding,
                        fillColor: this.options.tooltipFillColor,
                        textColor: this.options.tooltipFontColor,
                        fontFamily: this.options.tooltipFontFamily,
                        fontStyle: this.options.tooltipFontStyle,
                        fontSize: this.options.tooltipFontSize,
                        caretHeight: this.options.tooltipCaretSize,
                        cornerRadius: this.options.tooltipCornerRadius,
                        text: w(this.options.tooltipTemplate, t),
                        chart: this.chart,
                        custom: this.options.customTooltips
                    }).draw();
                }, this);
                return this;
            }
        },
        toBase64Image: function() {
            return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);
        }
    }), i.Type.extend = function(t) {
        var e = this, n = function() {
            return e.apply(this, arguments);
        };
        if (n.prototype = o(e.prototype), a(n.prototype, t), n.extend = i.Type.extend, t.name || e.prototype.name) {
            var s = t.name || e.prototype.name, l = i.defaults[e.prototype.name] ? o(i.defaults[e.prototype.name]) : {};
            i.defaults[s] = a(l, t.defaults), i.types[s] = n, i.prototype[s] = function(t, e) {
                var o = r(i.defaults.global, i.defaults[s], e || {});
                return new n(t, o, this);
            };
        } else d("Name not provided for this chart, so it hasn't been registered");
        return e;
    }, a((i.Element = function(t) {
        a(this, t), this.initialize.apply(this, arguments), this.save();
    }).prototype, {
        initialize: function() {},
        restore: function(t) {
            return t ? s(t, function(t) {
                this[t] = this._saved[t];
            }, this) : a(this, this._saved), this;
        },
        save: function() {
            return this._saved = o(this), delete this._saved._saved, this;
        },
        update: function(t) {
            return s(t, function(t, e) {
                this._saved[e] = this[e], this[e] = t;
            }, this), this;
        },
        transition: function(t, e) {
            return s(t, function(t, i) {
                this[i] = (t - this._saved[i]) * e + this._saved[i];
            }, this), this;
        },
        tooltipPosition: function() {
            return {
                x: this.x,
                y: this.y
            };
        },
        hasValue: function() {
            return p(this.value);
        }
    }), i.Element.extend = h, i.Point = i.Element.extend({
        display: !0,
        inRange: function(t, e) {
            var i = this.hitDetectionRadius + this.radius;
            return Math.pow(t - this.x, 2) + Math.pow(e - this.y, 2) < Math.pow(i, 2);
        },
        draw: function() {
            if (this.display) {
                var t = this.ctx;
                t.beginPath(), t.arc(this.x, this.y, this.radius, 0, 2 * Math.PI), t.closePath(), 
                t.strokeStyle = this.strokeColor, t.lineWidth = this.strokeWidth, t.fillStyle = this.fillColor, 
                t.fill(), t.stroke();
            }
        }
    }), i.Arc = i.Element.extend({
        inRange: function(t, e) {
            var i = n.getAngleFromPoint(this, {
                x: t,
                y: e
            }), s = i.angle >= this.startAngle && i.angle <= this.endAngle, o = i.distance >= this.innerRadius && i.distance <= this.outerRadius;
            return s && o;
        },
        tooltipPosition: function() {
            var t = this.startAngle + (this.endAngle - this.startAngle) / 2, e = (this.outerRadius - this.innerRadius) / 2 + this.innerRadius;
            return {
                x: this.x + Math.cos(t) * e,
                y: this.y + Math.sin(t) * e
            };
        },
        draw: function(t) {
            var e = this.ctx;
            e.beginPath(), e.arc(this.x, this.y, this.outerRadius, this.startAngle, this.endAngle), 
            e.arc(this.x, this.y, this.innerRadius, this.endAngle, this.startAngle, !0), e.closePath(), 
            e.strokeStyle = this.strokeColor, e.lineWidth = this.strokeWidth, e.fillStyle = this.fillColor, 
            e.fill(), e.lineJoin = "bevel", this.showStroke && e.stroke();
        }
    }), i.Rectangle = i.Element.extend({
        draw: function() {
            var t = this.ctx, e = this.width / 2, i = this.x - e, n = this.x + e, s = this.base - (this.base - this.y), o = this.strokeWidth / 2;
            this.showStroke && (i += o, n -= o, s += o), t.beginPath(), t.fillStyle = this.fillColor, 
            t.strokeStyle = this.strokeColor, t.lineWidth = this.strokeWidth, t.moveTo(i, this.base), 
            t.lineTo(i, s), t.lineTo(n, s), t.lineTo(n, this.base), t.fill(), this.showStroke && t.stroke();
        },
        height: function() {
            return this.base - this.y;
        },
        inRange: function(t, e) {
            return t >= this.x - this.width / 2 && t <= this.x + this.width / 2 && e >= this.y && e <= this.base;
        }
    }), i.Tooltip = i.Element.extend({
        draw: function() {
            var t = this.chart.ctx;
            t.font = L(this.fontSize, this.fontStyle, this.fontFamily), this.xAlign = "center", 
            this.yAlign = "above";
            var e = this.caretPadding = 2, i = t.measureText(this.text).width + 2 * this.xPadding, n = this.fontSize + 2 * this.yPadding, s = n + this.caretHeight + e;
            this.x + i / 2 > this.chart.width ? this.xAlign = "left" : this.x - i / 2 < 0 && (this.xAlign = "right"), 
            this.y - s < 0 && (this.yAlign = "below");
            var o = this.x - i / 2, a = this.y - s;
            if (t.fillStyle = this.fillColor, this.custom) this.custom(this); else {
                switch (this.yAlign) {
                  case "above":
                    t.beginPath(), t.moveTo(this.x, this.y - e), t.lineTo(this.x + this.caretHeight, this.y - (e + this.caretHeight)), 
                    t.lineTo(this.x - this.caretHeight, this.y - (e + this.caretHeight)), t.closePath(), 
                    t.fill();
                    break;

                  case "below":
                    a = this.y + e + this.caretHeight, t.beginPath(), t.moveTo(this.x, this.y + e), 
                    t.lineTo(this.x + this.caretHeight, this.y + e + this.caretHeight), t.lineTo(this.x - this.caretHeight, this.y + e + this.caretHeight), 
                    t.closePath(), t.fill();
                }
                switch (this.xAlign) {
                  case "left":
                    o = this.x - i + (this.cornerRadius + this.caretHeight);
                    break;

                  case "right":
                    o = this.x - (this.cornerRadius + this.caretHeight);
                }
                N(t, o, a, i, n, this.cornerRadius), t.fill(), t.fillStyle = this.textColor, t.textAlign = "center", 
                t.textBaseline = "middle", t.fillText(this.text, o + i / 2, a + n / 2);
            }
        }
    }), i.MultiTooltip = i.Element.extend({
        initialize: function() {
            this.font = L(this.fontSize, this.fontStyle, this.fontFamily), this.titleFont = L(this.titleFontSize, this.titleFontStyle, this.titleFontFamily), 
            this.height = this.labels.length * this.fontSize + (this.labels.length - 1) * (this.fontSize / 2) + 2 * this.yPadding + 1.5 * this.titleFontSize, 
            this.ctx.font = this.titleFont;
            var t = this.ctx.measureText(this.title).width, e = D(this.ctx, this.font, this.labels) + this.fontSize + 3, i = g([ e, t ]);
            this.width = i + 2 * this.xPadding;
            var n = this.height / 2;
            this.y - n < 0 ? this.y = n : this.y + n > this.chart.height && (this.y = this.chart.height - n), 
            this.x > this.chart.width / 2 ? this.x -= this.xOffset + this.width : this.x += this.xOffset;
        },
        getLineHeight: function(t) {
            var e = this.y - this.height / 2 + this.yPadding, i = t - 1;
            return 0 === t ? e + this.titleFontSize / 2 : e + (1.5 * this.fontSize * i + this.fontSize / 2) + 1.5 * this.titleFontSize;
        },
        draw: function() {
            if (this.custom) this.custom(this); else {
                N(this.ctx, this.x, this.y - this.height / 2, this.width, this.height, this.cornerRadius);
                var t = this.ctx;
                t.fillStyle = this.fillColor, t.fill(), t.closePath(), t.textAlign = "left", t.textBaseline = "middle", 
                t.fillStyle = this.titleTextColor, t.font = this.titleFont, t.fillText(this.title, this.x + this.xPadding, this.getLineHeight(0)), 
                t.font = this.font, n.each(this.labels, function(e, i) {
                    t.fillStyle = this.textColor, t.fillText(e, this.x + this.xPadding + this.fontSize + 3, this.getLineHeight(i + 1)), 
                    t.fillStyle = this.legendColorBackground, t.fillRect(this.x + this.xPadding, this.getLineHeight(i + 1) - this.fontSize / 2, this.fontSize, this.fontSize), 
                    t.fillStyle = this.legendColors[i].fill, t.fillRect(this.x + this.xPadding, this.getLineHeight(i + 1) - this.fontSize / 2, this.fontSize, this.fontSize);
                }, this);
            }
        }
    }), i.Scale = i.Element.extend({
        initialize: function() {
            this.fit();
        },
        buildYLabels: function() {
            this.yLabels = [];
            for (var t = m(this.stepValue), e = 0; e <= this.steps; e++) this.yLabels.push(w(this.templateString, {
                value: (this.min + e * this.stepValue).toFixed(t)
            }));
            this.yLabelWidth = this.display && this.showLabels ? D(this.ctx, this.font, this.yLabels) : 0;
        },
        addXLabel: function(t) {
            this.xLabels.push(t), this.valuesCount++, this.fit();
        },
        removeXLabel: function() {
            this.xLabels.shift(), this.valuesCount--, this.fit();
        },
        fit: function() {
            this.startPoint = this.display ? this.fontSize : 0, this.endPoint = this.display ? this.height - 1.5 * this.fontSize - 5 : this.height, 
            this.startPoint += this.padding, this.endPoint -= this.padding;
            var t, e = this.endPoint - this.startPoint;
            for (this.calculateYRange(e), this.buildYLabels(), this.calculateXLabelRotation(); e > this.endPoint - this.startPoint; ) e = this.endPoint - this.startPoint, 
            t = this.yLabelWidth, this.calculateYRange(e), this.buildYLabels(), t < this.yLabelWidth && this.calculateXLabelRotation();
        },
        calculateXLabelRotation: function() {
            this.ctx.font = this.font;
            var t, e = this.ctx.measureText(this.xLabels[0]).width, i = this.ctx.measureText(this.xLabels[this.xLabels.length - 1]).width;
            if (this.xScalePaddingRight = i / 2 + 3, this.xScalePaddingLeft = e / 2 > this.yLabelWidth + 10 ? e / 2 : this.yLabelWidth + 10, 
            this.xLabelRotation = 0, this.display) {
                var n, s = D(this.ctx, this.font, this.xLabels);
                this.xLabelWidth = s;
                for (var o = Math.floor(this.calculateX(1) - this.calculateX(0)) - 6; this.xLabelWidth > o && 0 === this.xLabelRotation || this.xLabelWidth > o && this.xLabelRotation <= 90 && this.xLabelRotation > 0; ) (n = Math.cos(y(this.xLabelRotation))) * i, 
                (t = n * e) + this.fontSize / 2 > this.yLabelWidth + 8 && (this.xScalePaddingLeft = t + this.fontSize / 2), 
                this.xScalePaddingRight = this.fontSize / 2, this.xLabelRotation++, this.xLabelWidth = n * s;
                this.xLabelRotation > 0 && (this.endPoint -= Math.sin(y(this.xLabelRotation)) * s + 3);
            } else this.xLabelWidth = 0, this.xScalePaddingRight = this.padding, this.xScalePaddingLeft = this.padding;
        },
        calculateYRange: c,
        drawingArea: function() {
            return this.startPoint - this.endPoint;
        },
        calculateY: function(t) {
            var e = this.drawingArea() / (this.min - this.max);
            return this.endPoint - e * (t - this.min);
        },
        calculateX: function(t) {
            this.xLabelRotation;
            var e = (this.width - (this.xScalePaddingLeft + this.xScalePaddingRight)) / Math.max(this.valuesCount - (this.offsetGridLines ? 0 : 1), 1), i = e * t + this.xScalePaddingLeft;
            return this.offsetGridLines && (i += e / 2), Math.round(i);
        },
        update: function(t) {
            n.extend(this, t), this.fit();
        },
        draw: function() {
            var t = this.ctx, e = (this.endPoint - this.startPoint) / this.steps, i = Math.round(this.xScalePaddingLeft);
            this.display && (t.fillStyle = this.textColor, t.font = this.font, s(this.yLabels, function(s, o) {
                var a = this.endPoint - e * o, r = Math.round(a), l = this.showHorizontalLines;
                t.textAlign = "right", t.textBaseline = "middle", this.showLabels && t.fillText(s, i - 10, a), 
                0 !== o || l || (l = !0), l && t.beginPath(), o > 0 ? (t.lineWidth = this.gridLineWidth, 
                t.strokeStyle = this.gridLineColor) : (t.lineWidth = this.lineWidth, t.strokeStyle = this.lineColor), 
                r += n.aliasPixel(t.lineWidth), l && (t.moveTo(i, r), t.lineTo(this.width, r), t.stroke(), 
                t.closePath()), t.lineWidth = this.lineWidth, t.strokeStyle = this.lineColor, t.beginPath(), 
                t.moveTo(i - 5, r), t.lineTo(i, r), t.stroke(), t.closePath();
            }, this), s(this.xLabels, function(e, i) {
                var n = this.calculateX(i) + _(this.lineWidth), s = this.calculateX(i - (this.offsetGridLines ? .5 : 0)) + _(this.lineWidth), o = this.xLabelRotation > 0, a = this.showVerticalLines;
                0 !== i || a || (a = !0), a && t.beginPath(), i > 0 ? (t.lineWidth = this.gridLineWidth, 
                t.strokeStyle = this.gridLineColor) : (t.lineWidth = this.lineWidth, t.strokeStyle = this.lineColor), 
                a && (t.moveTo(s, this.endPoint), t.lineTo(s, this.startPoint - 3), t.stroke(), 
                t.closePath()), t.lineWidth = this.lineWidth, t.strokeStyle = this.lineColor, t.beginPath(), 
                t.moveTo(s, this.endPoint), t.lineTo(s, this.endPoint + 5), t.stroke(), t.closePath(), 
                t.save(), t.translate(n, o ? this.endPoint + 12 : this.endPoint + 8), t.rotate(-1 * y(this.xLabelRotation)), 
                t.font = this.font, t.textAlign = o ? "right" : "center", t.textBaseline = o ? "middle" : "top", 
                t.fillText(e, 0, 0), t.restore();
            }, this));
        }
    }), i.RadialScale = i.Element.extend({
        initialize: function() {
            this.size = v([ this.height, this.width ]), this.drawingArea = this.display ? this.size / 2 - (this.fontSize / 2 + this.backdropPaddingY) : this.size / 2;
        },
        calculateCenterOffset: function(t) {
            var e = this.drawingArea / (this.max - this.min);
            return (t - this.min) * e;
        },
        update: function() {
            this.lineArc ? this.drawingArea = this.display ? this.size / 2 - (this.fontSize / 2 + this.backdropPaddingY) : this.size / 2 : this.setScaleSize(), 
            this.buildYLabels();
        },
        buildYLabels: function() {
            this.yLabels = [];
            for (var t = m(this.stepValue), e = 0; e <= this.steps; e++) this.yLabels.push(w(this.templateString, {
                value: (this.min + e * this.stepValue).toFixed(t)
            }));
        },
        getCircumference: function() {
            return 2 * Math.PI / this.valuesCount;
        },
        setScaleSize: function() {
            var t, e, i, n, s, o, a, r, l, h, c, u, d = v([ this.height / 2 - this.pointLabelFontSize - 5, this.width / 2 ]), f = this.width, g = 0;
            for (this.ctx.font = L(this.pointLabelFontSize, this.pointLabelFontStyle, this.pointLabelFontFamily), 
            e = 0; e < this.valuesCount; e++) t = this.getPointPosition(e, d), i = this.ctx.measureText(w(this.templateString, {
                value: this.labels[e]
            })).width + 5, 0 === e || e === this.valuesCount / 2 ? (n = i / 2, t.x + n > f && (f = t.x + n, 
            s = e), t.x - n < g && (g = t.x - n, a = e)) : e < this.valuesCount / 2 ? t.x + i > f && (f = t.x + i, 
            s = e) : e > this.valuesCount / 2 && t.x - i < g && (g = t.x - i, a = e);
            l = g, h = Math.ceil(f - this.width), o = this.getIndexAngle(s), r = this.getIndexAngle(a), 
            c = h / Math.sin(o + Math.PI / 2), u = l / Math.sin(r + Math.PI / 2), c = p(c) ? c : 0, 
            u = p(u) ? u : 0, this.drawingArea = d - (u + c) / 2, this.setCenterPoint(u, c);
        },
        setCenterPoint: function(t, e) {
            var i = this.width - e - this.drawingArea, n = t + this.drawingArea;
            this.xCenter = (n + i) / 2, this.yCenter = this.height / 2;
        },
        getIndexAngle: function(t) {
            return t * (2 * Math.PI / this.valuesCount) - Math.PI / 2;
        },
        getPointPosition: function(t, e) {
            var i = this.getIndexAngle(t);
            return {
                x: Math.cos(i) * e + this.xCenter,
                y: Math.sin(i) * e + this.yCenter
            };
        },
        draw: function() {
            if (this.display) {
                var t = this.ctx;
                if (s(this.yLabels, function(e, i) {
                    if (i > 0) {
                        var n, s = i * (this.drawingArea / this.steps), o = this.yCenter - s;
                        if (this.lineWidth > 0) if (t.strokeStyle = this.lineColor, t.lineWidth = this.lineWidth, 
                        this.lineArc) t.beginPath(), t.arc(this.xCenter, this.yCenter, s, 0, 2 * Math.PI), 
                        t.closePath(), t.stroke(); else {
                            t.beginPath();
                            for (var a = 0; a < this.valuesCount; a++) n = this.getPointPosition(a, this.calculateCenterOffset(this.min + i * this.stepValue)), 
                            0 === a ? t.moveTo(n.x, n.y) : t.lineTo(n.x, n.y);
                            t.closePath(), t.stroke();
                        }
                        if (this.showLabels) {
                            if (t.font = L(this.fontSize, this.fontStyle, this.fontFamily), this.showLabelBackdrop) {
                                var r = t.measureText(e).width;
                                t.fillStyle = this.backdropColor, t.fillRect(this.xCenter - r / 2 - this.backdropPaddingX, o - this.fontSize / 2 - this.backdropPaddingY, r + 2 * this.backdropPaddingX, this.fontSize + 2 * this.backdropPaddingY);
                            }
                            t.textAlign = "center", t.textBaseline = "middle", t.fillStyle = this.fontColor, 
                            t.fillText(e, this.xCenter, o);
                        }
                    }
                }, this), !this.lineArc) {
                    t.lineWidth = this.angleLineWidth, t.strokeStyle = this.angleLineColor;
                    for (var e = this.valuesCount - 1; e >= 0; e--) {
                        if (this.angleLineWidth > 0) {
                            var i = this.getPointPosition(e, this.calculateCenterOffset(this.max));
                            t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(i.x, i.y), t.stroke(), 
                            t.closePath();
                        }
                        var n = this.getPointPosition(e, this.calculateCenterOffset(this.max) + 5);
                        t.font = L(this.pointLabelFontSize, this.pointLabelFontStyle, this.pointLabelFontFamily), 
                        t.fillStyle = this.pointLabelFontColor;
                        var o = this.labels.length, a = this.labels.length / 2, r = a / 2, l = e < r || e > o - r, h = e === r || e === o - r;
                        t.textAlign = 0 === e ? "center" : e === a ? "center" : e < a ? "left" : "right", 
                        t.textBaseline = h ? "middle" : l ? "bottom" : "top", t.fillText(this.labels[e], n.x, n.y);
                    }
                }
            }
        }
    }), n.addEvent(window, "resize", function() {
        var t;
        return function() {
            clearTimeout(t), t = setTimeout(function() {
                s(i.instances, function(t) {
                    t.options.responsive && t.resize(t.render, !0);
                });
            }, 50);
        };
    }()), f ? define(function() {
        return i;
    }) : "object" == typeof module && module.exports && (module.exports = i), t.Chart = i, 
    i.noConflict = function() {
        return t.Chart = e, i;
    };
}).call(this), function() {
    var t = this.Chart, e = t.helpers, i = {
        scaleBeginAtZero: !0,
        scaleShowGridLines: !0,
        scaleGridLineColor: "rgba(0,0,0,.05)",
        scaleGridLineWidth: 1,
        scaleShowHorizontalLines: !0,
        scaleShowVerticalLines: !0,
        barShowStroke: !0,
        barStrokeWidth: 2,
        barValueSpacing: 5,
        barDatasetSpacing: 1,
        legendTemplate: '<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].fillColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'
    };
    t.Type.extend({
        name: "Bar",
        defaults: i,
        initialize: function(i) {
            var n = this.options;
            this.ScaleClass = t.Scale.extend({
                offsetGridLines: !0,
                calculateBarX: function(t, e, i) {
                    var s = this.calculateBaseWidth(), o = this.calculateX(i) - s / 2, a = this.calculateBarWidth(t);
                    return o + a * e + e * n.barDatasetSpacing + a / 2;
                },
                calculateBaseWidth: function() {
                    return this.calculateX(1) - this.calculateX(0) - 2 * n.barValueSpacing;
                },
                calculateBarWidth: function(t) {
                    return (this.calculateBaseWidth() - (t - 1) * n.barDatasetSpacing) / t;
                }
            }), this.datasets = [], this.options.showTooltips && e.bindEvents(this, this.options.tooltipEvents, function(t) {
                var i = "mouseout" !== t.type ? this.getBarsAtEvent(t) : [];
                this.eachBars(function(t) {
                    t.restore([ "fillColor", "strokeColor" ]);
                }), e.each(i, function(t) {
                    t.fillColor = t.highlightFill, t.strokeColor = t.highlightStroke;
                }), this.showTooltip(i);
            }), this.BarClass = t.Rectangle.extend({
                strokeWidth: this.options.barStrokeWidth,
                showStroke: this.options.barShowStroke,
                ctx: this.chart.ctx
            }), e.each(i.datasets, function(t, n) {
                var s = {
                    label: t.label || null,
                    fillColor: t.fillColor,
                    strokeColor: t.strokeColor,
                    bars: []
                };
                this.datasets.push(s), e.each(t.data, function(e, n) {
                    s.bars.push(new this.BarClass({
                        value: e,
                        label: i.labels[n],
                        datasetLabel: t.label,
                        strokeColor: t.strokeColor,
                        fillColor: t.fillColor,
                        highlightFill: t.highlightFill || t.fillColor,
                        highlightStroke: t.highlightStroke || t.strokeColor
                    }));
                }, this);
            }, this), this.buildScale(i.labels), this.BarClass.prototype.base = this.scale.endPoint, 
            this.eachBars(function(t, i, n) {
                e.extend(t, {
                    width: this.scale.calculateBarWidth(this.datasets.length),
                    x: this.scale.calculateBarX(this.datasets.length, n, i),
                    y: this.scale.endPoint
                }), t.save();
            }, this), this.render();
        },
        update: function() {
            this.scale.update(), e.each(this.activeElements, function(t) {
                t.restore([ "fillColor", "strokeColor" ]);
            }), this.eachBars(function(t) {
                t.save();
            }), this.render();
        },
        eachBars: function(t) {
            e.each(this.datasets, function(i, n) {
                e.each(i.bars, t, this, n);
            }, this);
        },
        getBarsAtEvent: function(t) {
            for (var i, n = [], s = e.getRelativePosition(t), o = function(t) {
                n.push(t.bars[i]);
            }, a = 0; a < this.datasets.length; a++) for (i = 0; i < this.datasets[a].bars.length; i++) if (this.datasets[a].bars[i].inRange(s.x, s.y)) return e.each(this.datasets, o), 
            n;
            return n;
        },
        buildScale: function(t) {
            var i = this, n = function() {
                var t = [];
                return i.eachBars(function(e) {
                    t.push(e.value);
                }), t;
            }, s = {
                templateString: this.options.scaleLabel,
                height: this.chart.height,
                width: this.chart.width,
                ctx: this.chart.ctx,
                textColor: this.options.scaleFontColor,
                fontSize: this.options.scaleFontSize,
                fontStyle: this.options.scaleFontStyle,
                fontFamily: this.options.scaleFontFamily,
                valuesCount: t.length,
                beginAtZero: this.options.scaleBeginAtZero,
                integersOnly: this.options.scaleIntegersOnly,
                calculateYRange: function(t) {
                    var i = e.calculateScaleRange(n(), t, this.fontSize, this.beginAtZero, this.integersOnly);
                    e.extend(this, i);
                },
                xLabels: t,
                font: e.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily),
                lineWidth: this.options.scaleLineWidth,
                lineColor: this.options.scaleLineColor,
                showHorizontalLines: this.options.scaleShowHorizontalLines,
                showVerticalLines: this.options.scaleShowVerticalLines,
                gridLineWidth: this.options.scaleShowGridLines ? this.options.scaleGridLineWidth : 0,
                gridLineColor: this.options.scaleShowGridLines ? this.options.scaleGridLineColor : "rgba(0,0,0,0)",
                padding: this.options.showScale ? 0 : this.options.barShowStroke ? this.options.barStrokeWidth : 0,
                showLabels: this.options.scaleShowLabels,
                display: this.options.showScale
            };
            this.options.scaleOverride && e.extend(s, {
                calculateYRange: e.noop,
                steps: this.options.scaleSteps,
                stepValue: this.options.scaleStepWidth,
                min: this.options.scaleStartValue,
                max: this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth
            }), this.scale = new this.ScaleClass(s);
        },
        addData: function(t, i) {
            e.each(t, function(t, e) {
                this.datasets[e].bars.push(new this.BarClass({
                    value: t,
                    label: i,
                    x: this.scale.calculateBarX(this.datasets.length, e, this.scale.valuesCount + 1),
                    y: this.scale.endPoint,
                    width: this.scale.calculateBarWidth(this.datasets.length),
                    base: this.scale.endPoint,
                    strokeColor: this.datasets[e].strokeColor,
                    fillColor: this.datasets[e].fillColor
                }));
            }, this), this.scale.addXLabel(i), this.update();
        },
        removeData: function() {
            this.scale.removeXLabel(), e.each(this.datasets, function(t) {
                t.bars.shift();
            }, this), this.update();
        },
        reflow: function() {
            e.extend(this.BarClass.prototype, {
                y: this.scale.endPoint,
                base: this.scale.endPoint
            });
            var t = e.extend({
                height: this.chart.height,
                width: this.chart.width
            });
            this.scale.update(t);
        },
        draw: function(t) {
            var i = t || 1;
            this.clear();
            this.chart.ctx;
            this.scale.draw(i), e.each(this.datasets, function(t, n) {
                e.each(t.bars, function(t, e) {
                    t.hasValue() && (t.base = this.scale.endPoint, t.transition({
                        x: this.scale.calculateBarX(this.datasets.length, n, e),
                        y: this.scale.calculateY(t.value),
                        width: this.scale.calculateBarWidth(this.datasets.length)
                    }, i).draw());
                }, this);
            }, this);
        }
    });
}.call(this), function() {
    var t = this.Chart, e = t.helpers, i = {
        segmentShowStroke: !0,
        segmentStrokeColor: "#fff",
        segmentStrokeWidth: 2,
        percentageInnerCutout: 50,
        animationSteps: 100,
        animationEasing: "easeOutBounce",
        animateRotate: !0,
        animateScale: !1,
        legendTemplate: '<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'
    };
    t.Type.extend({
        name: "Doughnut",
        defaults: i,
        initialize: function(i) {
            this.segments = [], this.outerRadius = (e.min([ this.chart.width, this.chart.height ]) - this.options.segmentStrokeWidth / 2) / 2, 
            this.SegmentArc = t.Arc.extend({
                ctx: this.chart.ctx,
                x: this.chart.width / 2,
                y: this.chart.height / 2
            }), this.options.showTooltips && e.bindEvents(this, this.options.tooltipEvents, function(t) {
                var i = "mouseout" !== t.type ? this.getSegmentsAtEvent(t) : [];
                e.each(this.segments, function(t) {
                    t.restore([ "fillColor" ]);
                }), e.each(i, function(t) {
                    t.fillColor = t.highlightColor;
                }), this.showTooltip(i);
            }), this.calculateTotal(i), e.each(i, function(t, e) {
                this.addData(t, e, !0);
            }, this), this.render();
        },
        getSegmentsAtEvent: function(t) {
            var i = [], n = e.getRelativePosition(t);
            return e.each(this.segments, function(t) {
                t.inRange(n.x, n.y) && i.push(t);
            }, this), i;
        },
        addData: function(t, e, i) {
            var n = e || this.segments.length;
            this.segments.splice(n, 0, new this.SegmentArc({
                value: t.value,
                outerRadius: this.options.animateScale ? 0 : this.outerRadius,
                innerRadius: this.options.animateScale ? 0 : this.outerRadius / 100 * this.options.percentageInnerCutout,
                fillColor: t.color,
                highlightColor: t.highlight || t.color,
                showStroke: this.options.segmentShowStroke,
                strokeWidth: this.options.segmentStrokeWidth,
                strokeColor: this.options.segmentStrokeColor,
                startAngle: 1.5 * Math.PI,
                circumference: this.options.animateRotate ? 0 : this.calculateCircumference(t.value),
                label: t.label
            })), i || (this.reflow(), this.update());
        },
        calculateCircumference: function(t) {
            return 2 * Math.PI * (Math.abs(t) / this.total);
        },
        calculateTotal: function(t) {
            this.total = 0, e.each(t, function(t) {
                this.total += Math.abs(t.value);
            }, this);
        },
        update: function() {
            this.calculateTotal(this.segments), e.each(this.activeElements, function(t) {
                t.restore([ "fillColor" ]);
            }), e.each(this.segments, function(t) {
                t.save();
            }), this.render();
        },
        removeData: function(t) {
            var i = e.isNumber(t) ? t : this.segments.length - 1;
            this.segments.splice(i, 1), this.reflow(), this.update();
        },
        reflow: function() {
            e.extend(this.SegmentArc.prototype, {
                x: this.chart.width / 2,
                y: this.chart.height / 2
            }), this.outerRadius = (e.min([ this.chart.width, this.chart.height ]) - this.options.segmentStrokeWidth / 2) / 2, 
            e.each(this.segments, function(t) {
                t.update({
                    outerRadius: this.outerRadius,
                    innerRadius: this.outerRadius / 100 * this.options.percentageInnerCutout
                });
            }, this);
        },
        draw: function(t) {
            var i = t || 1;
            this.clear(), e.each(this.segments, function(t, e) {
                t.transition({
                    circumference: this.calculateCircumference(t.value),
                    outerRadius: this.outerRadius,
                    innerRadius: this.outerRadius / 100 * this.options.percentageInnerCutout
                }, i), t.endAngle = t.startAngle + t.circumference, t.draw(), 0 === e && (t.startAngle = 1.5 * Math.PI), 
                e < this.segments.length - 1 && (this.segments[e + 1].startAngle = t.endAngle);
            }, this);
        }
    }), t.types.Doughnut.extend({
        name: "Pie",
        defaults: e.merge(i, {
            percentageInnerCutout: 0
        })
    });
}.call(this), function() {
    var t = this.Chart, e = t.helpers, i = {
        scaleShowGridLines: !0,
        scaleGridLineColor: "rgba(0,0,0,.05)",
        scaleGridLineWidth: 1,
        scaleShowHorizontalLines: !0,
        scaleShowVerticalLines: !0,
        bezierCurve: !0,
        bezierCurveTension: .4,
        pointDot: !0,
        pointDotRadius: 4,
        pointDotStrokeWidth: 1,
        pointHitDetectionRadius: 20,
        datasetStroke: !0,
        datasetStrokeWidth: 2,
        datasetFill: !0,
        legendTemplate: '<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'
    };
    t.Type.extend({
        name: "Line",
        defaults: i,
        initialize: function(i) {
            this.PointClass = t.Point.extend({
                strokeWidth: this.options.pointDotStrokeWidth,
                radius: this.options.pointDotRadius,
                display: this.options.pointDot,
                hitDetectionRadius: this.options.pointHitDetectionRadius,
                ctx: this.chart.ctx,
                inRange: function(t) {
                    return Math.pow(t - this.x, 2) < Math.pow(this.radius + this.hitDetectionRadius, 2);
                }
            }), this.datasets = [], this.options.showTooltips && e.bindEvents(this, this.options.tooltipEvents, function(t) {
                var i = "mouseout" !== t.type ? this.getPointsAtEvent(t) : [];
                this.eachPoints(function(t) {
                    t.restore([ "fillColor", "strokeColor" ]);
                }), e.each(i, function(t) {
                    t.fillColor = t.highlightFill, t.strokeColor = t.highlightStroke;
                }), this.showTooltip(i);
            }), e.each(i.datasets, function(t) {
                var n = {
                    label: t.label || null,
                    fillColor: t.fillColor,
                    strokeColor: t.strokeColor,
                    pointColor: t.pointColor,
                    pointStrokeColor: t.pointStrokeColor,
                    points: []
                };
                this.datasets.push(n), e.each(t.data, function(e, s) {
                    n.points.push(new this.PointClass({
                        value: e,
                        label: i.labels[s],
                        datasetLabel: t.label,
                        strokeColor: t.pointStrokeColor,
                        fillColor: t.pointColor,
                        highlightFill: t.pointHighlightFill || t.pointColor,
                        highlightStroke: t.pointHighlightStroke || t.pointStrokeColor
                    }));
                }, this), this.buildScale(i.labels), this.eachPoints(function(t, i) {
                    e.extend(t, {
                        x: this.scale.calculateX(i),
                        y: this.scale.endPoint
                    }), t.save();
                }, this);
            }, this), this.render();
        },
        update: function() {
            this.scale.update(), e.each(this.activeElements, function(t) {
                t.restore([ "fillColor", "strokeColor" ]);
            }), this.eachPoints(function(t) {
                t.save();
            }), this.render();
        },
        eachPoints: function(t) {
            e.each(this.datasets, function(i) {
                e.each(i.points, t, this);
            }, this);
        },
        getPointsAtEvent: function(t) {
            var i = [], n = e.getRelativePosition(t);
            return e.each(this.datasets, function(t) {
                e.each(t.points, function(t) {
                    t.inRange(n.x, n.y) && i.push(t);
                });
            }, this), i;
        },
        buildScale: function(i) {
            var n = this, s = function() {
                var t = [];
                return n.eachPoints(function(e) {
                    t.push(e.value);
                }), t;
            }, o = {
                templateString: this.options.scaleLabel,
                height: this.chart.height,
                width: this.chart.width,
                ctx: this.chart.ctx,
                textColor: this.options.scaleFontColor,
                fontSize: this.options.scaleFontSize,
                fontStyle: this.options.scaleFontStyle,
                fontFamily: this.options.scaleFontFamily,
                valuesCount: i.length,
                beginAtZero: this.options.scaleBeginAtZero,
                integersOnly: this.options.scaleIntegersOnly,
                calculateYRange: function(t) {
                    var i = e.calculateScaleRange(s(), t, this.fontSize, this.beginAtZero, this.integersOnly);
                    e.extend(this, i);
                },
                xLabels: i,
                font: e.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily),
                lineWidth: this.options.scaleLineWidth,
                lineColor: this.options.scaleLineColor,
                showHorizontalLines: this.options.scaleShowHorizontalLines,
                showVerticalLines: this.options.scaleShowVerticalLines,
                gridLineWidth: this.options.scaleShowGridLines ? this.options.scaleGridLineWidth : 0,
                gridLineColor: this.options.scaleShowGridLines ? this.options.scaleGridLineColor : "rgba(0,0,0,0)",
                padding: this.options.showScale ? 0 : this.options.pointDotRadius + this.options.pointDotStrokeWidth,
                showLabels: this.options.scaleShowLabels,
                display: this.options.showScale
            };
            this.options.scaleOverride && e.extend(o, {
                calculateYRange: e.noop,
                steps: this.options.scaleSteps,
                stepValue: this.options.scaleStepWidth,
                min: this.options.scaleStartValue,
                max: this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth
            }), this.scale = new t.Scale(o);
        },
        addData: function(t, i) {
            e.each(t, function(t, e) {
                this.datasets[e].points.push(new this.PointClass({
                    value: t,
                    label: i,
                    x: this.scale.calculateX(this.scale.valuesCount + 1),
                    y: this.scale.endPoint,
                    strokeColor: this.datasets[e].pointStrokeColor,
                    fillColor: this.datasets[e].pointColor
                }));
            }, this), this.scale.addXLabel(i), this.update();
        },
        removeData: function() {
            this.scale.removeXLabel(), e.each(this.datasets, function(t) {
                t.points.shift();
            }, this), this.update();
        },
        reflow: function() {
            var t = e.extend({
                height: this.chart.height,
                width: this.chart.width
            });
            this.scale.update(t);
        },
        draw: function(t) {
            var i = t || 1;
            this.clear();
            var n = this.chart.ctx, s = function(t) {
                return null !== t.value;
            }, o = function(t, i, n) {
                return e.findNextWhere(i, s, n) || t;
            }, a = function(t, i, n) {
                return e.findPreviousWhere(i, s, n) || t;
            };
            this.scale.draw(i), e.each(this.datasets, function(t) {
                var r = e.where(t.points, s);
                e.each(t.points, function(t, e) {
                    t.hasValue() && t.transition({
                        y: this.scale.calculateY(t.value),
                        x: this.scale.calculateX(e)
                    }, i);
                }, this), this.options.bezierCurve && e.each(r, function(t, i) {
                    var n = i > 0 && i < r.length - 1 ? this.options.bezierCurveTension : 0;
                    t.controlPoints = e.splineCurve(a(t, r, i), t, o(t, r, i), n), t.controlPoints.outer.y > this.scale.endPoint ? t.controlPoints.outer.y = this.scale.endPoint : t.controlPoints.outer.y < this.scale.startPoint && (t.controlPoints.outer.y = this.scale.startPoint), 
                    t.controlPoints.inner.y > this.scale.endPoint ? t.controlPoints.inner.y = this.scale.endPoint : t.controlPoints.inner.y < this.scale.startPoint && (t.controlPoints.inner.y = this.scale.startPoint);
                }, this), n.lineWidth = this.options.datasetStrokeWidth, n.strokeStyle = t.strokeColor, 
                n.beginPath(), e.each(r, function(t, e) {
                    if (0 === e) n.moveTo(t.x, t.y); else if (this.options.bezierCurve) {
                        var i = a(t, r, e);
                        n.bezierCurveTo(i.controlPoints.outer.x, i.controlPoints.outer.y, t.controlPoints.inner.x, t.controlPoints.inner.y, t.x, t.y);
                    } else n.lineTo(t.x, t.y);
                }, this), n.stroke(), this.options.datasetFill && r.length > 0 && (n.lineTo(r[r.length - 1].x, this.scale.endPoint), 
                n.lineTo(r[0].x, this.scale.endPoint), n.fillStyle = t.fillColor, n.closePath(), 
                n.fill()), e.each(r, function(t) {
                    t.draw();
                });
            }, this);
        }
    });
}.call(this), function() {
    var t = this.Chart, e = t.helpers, i = {
        scaleShowLabelBackdrop: !0,
        scaleBackdropColor: "rgba(255,255,255,0.75)",
        scaleBeginAtZero: !0,
        scaleBackdropPaddingY: 2,
        scaleBackdropPaddingX: 2,
        scaleShowLine: !0,
        segmentShowStroke: !0,
        segmentStrokeColor: "#fff",
        segmentStrokeWidth: 2,
        animationSteps: 100,
        animationEasing: "easeOutBounce",
        animateRotate: !0,
        animateScale: !1,
        legendTemplate: '<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'
    };
    t.Type.extend({
        name: "PolarArea",
        defaults: i,
        initialize: function(i) {
            this.segments = [], this.SegmentArc = t.Arc.extend({
                showStroke: this.options.segmentShowStroke,
                strokeWidth: this.options.segmentStrokeWidth,
                strokeColor: this.options.segmentStrokeColor,
                ctx: this.chart.ctx,
                innerRadius: 0,
                x: this.chart.width / 2,
                y: this.chart.height / 2
            }), this.scale = new t.RadialScale({
                display: this.options.showScale,
                fontStyle: this.options.scaleFontStyle,
                fontSize: this.options.scaleFontSize,
                fontFamily: this.options.scaleFontFamily,
                fontColor: this.options.scaleFontColor,
                showLabels: this.options.scaleShowLabels,
                showLabelBackdrop: this.options.scaleShowLabelBackdrop,
                backdropColor: this.options.scaleBackdropColor,
                backdropPaddingY: this.options.scaleBackdropPaddingY,
                backdropPaddingX: this.options.scaleBackdropPaddingX,
                lineWidth: this.options.scaleShowLine ? this.options.scaleLineWidth : 0,
                lineColor: this.options.scaleLineColor,
                lineArc: !0,
                width: this.chart.width,
                height: this.chart.height,
                xCenter: this.chart.width / 2,
                yCenter: this.chart.height / 2,
                ctx: this.chart.ctx,
                templateString: this.options.scaleLabel,
                valuesCount: i.length
            }), this.updateScaleRange(i), this.scale.update(), e.each(i, function(t, e) {
                this.addData(t, e, !0);
            }, this), this.options.showTooltips && e.bindEvents(this, this.options.tooltipEvents, function(t) {
                var i = "mouseout" !== t.type ? this.getSegmentsAtEvent(t) : [];
                e.each(this.segments, function(t) {
                    t.restore([ "fillColor" ]);
                }), e.each(i, function(t) {
                    t.fillColor = t.highlightColor;
                }), this.showTooltip(i);
            }), this.render();
        },
        getSegmentsAtEvent: function(t) {
            var i = [], n = e.getRelativePosition(t);
            return e.each(this.segments, function(t) {
                t.inRange(n.x, n.y) && i.push(t);
            }, this), i;
        },
        addData: function(t, e, i) {
            var n = e || this.segments.length;
            this.segments.splice(n, 0, new this.SegmentArc({
                fillColor: t.color,
                highlightColor: t.highlight || t.color,
                label: t.label,
                value: t.value,
                outerRadius: this.options.animateScale ? 0 : this.scale.calculateCenterOffset(t.value),
                circumference: this.options.animateRotate ? 0 : this.scale.getCircumference(),
                startAngle: 1.5 * Math.PI
            })), i || (this.reflow(), this.update());
        },
        removeData: function(t) {
            var i = e.isNumber(t) ? t : this.segments.length - 1;
            this.segments.splice(i, 1), this.reflow(), this.update();
        },
        calculateTotal: function(t) {
            this.total = 0, e.each(t, function(t) {
                this.total += t.value;
            }, this), this.scale.valuesCount = this.segments.length;
        },
        updateScaleRange: function(t) {
            var i = [];
            e.each(t, function(t) {
                i.push(t.value);
            });
            var n = this.options.scaleOverride ? {
                steps: this.options.scaleSteps,
                stepValue: this.options.scaleStepWidth,
                min: this.options.scaleStartValue,
                max: this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth
            } : e.calculateScaleRange(i, e.min([ this.chart.width, this.chart.height ]) / 2, this.options.scaleFontSize, this.options.scaleBeginAtZero, this.options.scaleIntegersOnly);
            e.extend(this.scale, n, {
                size: e.min([ this.chart.width, this.chart.height ]),
                xCenter: this.chart.width / 2,
                yCenter: this.chart.height / 2
            });
        },
        update: function() {
            this.calculateTotal(this.segments), e.each(this.segments, function(t) {
                t.save();
            }), this.reflow(), this.render();
        },
        reflow: function() {
            e.extend(this.SegmentArc.prototype, {
                x: this.chart.width / 2,
                y: this.chart.height / 2
            }), this.updateScaleRange(this.segments), this.scale.update(), e.extend(this.scale, {
                xCenter: this.chart.width / 2,
                yCenter: this.chart.height / 2
            }), e.each(this.segments, function(t) {
                t.update({
                    outerRadius: this.scale.calculateCenterOffset(t.value)
                });
            }, this);
        },
        draw: function(t) {
            var i = t || 1;
            this.clear(), e.each(this.segments, function(t, e) {
                t.transition({
                    circumference: this.scale.getCircumference(),
                    outerRadius: this.scale.calculateCenterOffset(t.value)
                }, i), t.endAngle = t.startAngle + t.circumference, 0 === e && (t.startAngle = 1.5 * Math.PI), 
                e < this.segments.length - 1 && (this.segments[e + 1].startAngle = t.endAngle), 
                t.draw();
            }, this), this.scale.draw();
        }
    });
}.call(this), function() {
    var t = this.Chart, e = t.helpers;
    t.Type.extend({
        name: "Radar",
        defaults: {
            scaleShowLine: !0,
            angleShowLineOut: !0,
            scaleShowLabels: !1,
            scaleBeginAtZero: !0,
            angleLineColor: "rgba(0,0,0,.1)",
            angleLineWidth: 1,
            pointLabelFontFamily: "'Arial'",
            pointLabelFontStyle: "normal",
            pointLabelFontSize: 10,
            pointLabelFontColor: "#666",
            pointDot: !0,
            pointDotRadius: 3,
            pointDotStrokeWidth: 1,
            pointHitDetectionRadius: 20,
            datasetStroke: !0,
            datasetStrokeWidth: 2,
            datasetFill: !0,
            legendTemplate: '<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'
        },
        initialize: function(i) {
            this.PointClass = t.Point.extend({
                strokeWidth: this.options.pointDotStrokeWidth,
                radius: this.options.pointDotRadius,
                display: this.options.pointDot,
                hitDetectionRadius: this.options.pointHitDetectionRadius,
                ctx: this.chart.ctx
            }), this.datasets = [], this.buildScale(i), this.options.showTooltips && e.bindEvents(this, this.options.tooltipEvents, function(t) {
                var i = "mouseout" !== t.type ? this.getPointsAtEvent(t) : [];
                this.eachPoints(function(t) {
                    t.restore([ "fillColor", "strokeColor" ]);
                }), e.each(i, function(t) {
                    t.fillColor = t.highlightFill, t.strokeColor = t.highlightStroke;
                }), this.showTooltip(i);
            }), e.each(i.datasets, function(t) {
                var n = {
                    label: t.label || null,
                    fillColor: t.fillColor,
                    strokeColor: t.strokeColor,
                    pointColor: t.pointColor,
                    pointStrokeColor: t.pointStrokeColor,
                    points: []
                };
                this.datasets.push(n), e.each(t.data, function(e, s) {
                    var o;
                    this.scale.animation || (o = this.scale.getPointPosition(s, this.scale.calculateCenterOffset(e))), 
                    n.points.push(new this.PointClass({
                        value: e,
                        label: i.labels[s],
                        datasetLabel: t.label,
                        x: this.options.animation ? this.scale.xCenter : o.x,
                        y: this.options.animation ? this.scale.yCenter : o.y,
                        strokeColor: t.pointStrokeColor,
                        fillColor: t.pointColor,
                        highlightFill: t.pointHighlightFill || t.pointColor,
                        highlightStroke: t.pointHighlightStroke || t.pointStrokeColor
                    }));
                }, this);
            }, this), this.render();
        },
        eachPoints: function(t) {
            e.each(this.datasets, function(i) {
                e.each(i.points, t, this);
            }, this);
        },
        getPointsAtEvent: function(t) {
            var i = e.getRelativePosition(t), n = e.getAngleFromPoint({
                x: this.scale.xCenter,
                y: this.scale.yCenter
            }, i), s = 2 * Math.PI / this.scale.valuesCount, o = Math.round((n.angle - 1.5 * Math.PI) / s), a = [];
            return (o >= this.scale.valuesCount || o < 0) && (o = 0), n.distance <= this.scale.drawingArea && e.each(this.datasets, function(t) {
                a.push(t.points[o]);
            }), a;
        },
        buildScale: function(e) {
            this.scale = new t.RadialScale({
                display: this.options.showScale,
                fontStyle: this.options.scaleFontStyle,
                fontSize: this.options.scaleFontSize,
                fontFamily: this.options.scaleFontFamily,
                fontColor: this.options.scaleFontColor,
                showLabels: this.options.scaleShowLabels,
                showLabelBackdrop: this.options.scaleShowLabelBackdrop,
                backdropColor: this.options.scaleBackdropColor,
                backdropPaddingY: this.options.scaleBackdropPaddingY,
                backdropPaddingX: this.options.scaleBackdropPaddingX,
                lineWidth: this.options.scaleShowLine ? this.options.scaleLineWidth : 0,
                lineColor: this.options.scaleLineColor,
                angleLineColor: this.options.angleLineColor,
                angleLineWidth: this.options.angleShowLineOut ? this.options.angleLineWidth : 0,
                pointLabelFontColor: this.options.pointLabelFontColor,
                pointLabelFontSize: this.options.pointLabelFontSize,
                pointLabelFontFamily: this.options.pointLabelFontFamily,
                pointLabelFontStyle: this.options.pointLabelFontStyle,
                height: this.chart.height,
                width: this.chart.width,
                xCenter: this.chart.width / 2,
                yCenter: this.chart.height / 2,
                ctx: this.chart.ctx,
                templateString: this.options.scaleLabel,
                labels: e.labels,
                valuesCount: e.datasets[0].data.length
            }), this.scale.setScaleSize(), this.updateScaleRange(e.datasets), this.scale.buildYLabels();
        },
        updateScaleRange: function(t) {
            var i = function() {
                var i = [];
                return e.each(t, function(t) {
                    t.data ? i = i.concat(t.data) : e.each(t.points, function(t) {
                        i.push(t.value);
                    });
                }), i;
            }(), n = this.options.scaleOverride ? {
                steps: this.options.scaleSteps,
                stepValue: this.options.scaleStepWidth,
                min: this.options.scaleStartValue,
                max: this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth
            } : e.calculateScaleRange(i, e.min([ this.chart.width, this.chart.height ]) / 2, this.options.scaleFontSize, this.options.scaleBeginAtZero, this.options.scaleIntegersOnly);
            e.extend(this.scale, n);
        },
        addData: function(t, i) {
            this.scale.valuesCount++, e.each(t, function(t, e) {
                var n = this.scale.getPointPosition(this.scale.valuesCount, this.scale.calculateCenterOffset(t));
                this.datasets[e].points.push(new this.PointClass({
                    value: t,
                    label: i,
                    x: n.x,
                    y: n.y,
                    strokeColor: this.datasets[e].pointStrokeColor,
                    fillColor: this.datasets[e].pointColor
                }));
            }, this), this.scale.labels.push(i), this.reflow(), this.update();
        },
        removeData: function() {
            this.scale.valuesCount--, this.scale.labels.shift(), e.each(this.datasets, function(t) {
                t.points.shift();
            }, this), this.reflow(), this.update();
        },
        update: function() {
            this.eachPoints(function(t) {
                t.save();
            }), this.reflow(), this.render();
        },
        reflow: function() {
            e.extend(this.scale, {
                width: this.chart.width,
                height: this.chart.height,
                size: e.min([ this.chart.width, this.chart.height ]),
                xCenter: this.chart.width / 2,
                yCenter: this.chart.height / 2
            }), this.updateScaleRange(this.datasets), this.scale.setScaleSize(), this.scale.buildYLabels();
        },
        draw: function(t) {
            var i = t || 1, n = this.chart.ctx;
            this.clear(), this.scale.draw(), e.each(this.datasets, function(t) {
                e.each(t.points, function(t, e) {
                    t.hasValue() && t.transition(this.scale.getPointPosition(e, this.scale.calculateCenterOffset(t.value)), i);
                }, this), n.lineWidth = this.options.datasetStrokeWidth, n.strokeStyle = t.strokeColor, 
                n.beginPath(), e.each(t.points, function(t, e) {
                    0 === e ? n.moveTo(t.x, t.y) : n.lineTo(t.x, t.y);
                }, this), n.closePath(), n.stroke(), n.fillStyle = t.fillColor, n.fill(), e.each(t.points, function(t) {
                    t.hasValue() && t.draw();
                });
            }, this);
        }
    });
}.call(this), function(t) {
    "function" == typeof define && define.amd ? define([ "jquery" ], t) : t("object" == typeof module && module.exports ? require("jquery") : jQuery);
}(function(t) {
    function e(e) {
        var i = {}, n = /^jQuery\d+$/;
        return t.each(e.attributes, function(t, e) {
            e.specified && !n.test(e.name) && (i[e.name] = e.value);
        }), i;
    }
    function i(e, i) {
        var n = this, o = t(n);
        if (n.value === o.attr("placeholder") && o.hasClass(d.customClass)) if (n.value = "", 
        o.removeClass(d.customClass), o.data("placeholder-password")) {
            if (o = o.hide().nextAll('input[type="password"]:first').show().attr("id", o.removeAttr("id").data("placeholder-id")), 
            !0 === e) return o[0].value = i, i;
            o.focus();
        } else n == s() && n.select();
    }
    function n(n) {
        var s, o = this, a = t(o), r = o.id;
        if (n && "blur" === n.type) {
            if (a.hasClass(d.customClass)) return;
            if ("password" === o.type && (s = a.prevAll('input[type="text"]:first')).length > 0 && s.is(":visible")) return;
        }
        if ("" === o.value) {
            if ("password" === o.type) {
                if (!a.data("placeholder-textinput")) {
                    try {
                        s = a.clone().prop({
                            type: "text"
                        });
                    } catch (i) {
                        s = t("<input>").attr(t.extend(e(this), {
                            type: "text"
                        }));
                    }
                    s.removeAttr("name").data({
                        "placeholder-enabled": !0,
                        "placeholder-password": a,
                        "placeholder-id": r
                    }).bind("focus.placeholder", i), a.data({
                        "placeholder-textinput": s,
                        "placeholder-id": r
                    }).before(s);
                }
                o.value = "", a = a.removeAttr("id").hide().prevAll('input[type="text"]:first').attr("id", a.data("placeholder-id")).show();
            } else {
                var l = a.data("placeholder-password");
                l && (l[0].value = "", a.attr("id", a.data("placeholder-id")).show().nextAll('input[type="password"]:last').hide().removeAttr("id"));
            }
            a.addClass(d.customClass), a[0].value = a.attr("placeholder");
        } else a.removeClass(d.customClass);
    }
    function s() {
        try {
            return document.activeElement;
        } catch (t) {}
    }
    var o, a, r = "[object OperaMini]" === Object.prototype.toString.call(window.operamini), l = "placeholder" in document.createElement("input") && !r, h = "placeholder" in document.createElement("textarea") && !r, c = t.valHooks, u = t.propHooks, d = {};
    l && h ? ((a = t.fn.placeholder = function() {
        return this;
    }).input = !0, a.textarea = !0) : ((a = t.fn.placeholder = function(e) {
        var s = {
            customClass: "placeholder"
        };
        return d = t.extend({}, s, e), this.filter((l ? "textarea" : ":input") + "[placeholder]").not("." + d.customClass).bind({
            "focus.placeholder": i,
            "blur.placeholder": n
        }).data("placeholder-enabled", !0).trigger("blur.placeholder");
    }).input = l, a.textarea = h, o = {
        get: function(e) {
            var i = t(e), n = i.data("placeholder-password");
            return n ? n[0].value : i.data("placeholder-enabled") && i.hasClass(d.customClass) ? "" : e.value;
        },
        set: function(e, o) {
            var a, r, l = t(e);
            return "" !== o && (a = l.data("placeholder-textinput"), r = l.data("placeholder-password"), 
            a ? (i.call(a[0], !0, o) || (e.value = o), a[0].value = o) : r && (i.call(e, !0, o) || (r[0].value = o), 
            e.value = o)), l.data("placeholder-enabled") ? ("" === o ? (e.value = o, e != s() && n.call(e)) : (l.hasClass(d.customClass) && i.call(e), 
            e.value = o), l) : (e.value = o, l);
        }
    }, l || (c.input = o, u.value = o), h || (c.textarea = o, u.value = o), t(function() {
        t(document).delegate("form", "submit.placeholder", function() {
            var e = t("." + d.customClass, this).each(function() {
                i.call(this, !0, "");
            });
            setTimeout(function() {
                e.each(n);
            }, 10);
        });
    }), t(window).bind("beforeunload.placeholder", function() {
        t("." + d.customClass).each(function() {
            this.value = "";
        });
    }));
}), function(t, e) {
    var i = {
        catchMethods: {
            methodreturn: [],
            count: 0
        },
        init: function(e) {
            var i, n, s;
            e.originalEvent.origin.match(/vimeo/g) && "data" in e.originalEvent && (s = "string" === t.type(e.originalEvent.data) ? t.parseJSON(e.originalEvent.data) : e.originalEvent.data) && (i = this.setPlayerID(s)).length && (n = this.setVimeoAPIurl(i), 
            s.hasOwnProperty("event") && this.handleEvent(s, i, n), s.hasOwnProperty("method") && this.handleMethod(s, i, n));
        },
        setPlayerID: function(e) {
            return t("iframe[src*=" + e.player_id + "]");
        },
        setVimeoAPIurl: function(t) {
            return "http" !== t.attr("src").substr(0, 4) ? "https:" + t.attr("src").split("?")[0] : t.attr("src").split("?")[0];
        },
        handleMethod: function(t, e, i) {
            this.catchMethods.methodreturn.push(t.value);
        },
        handleEvent: function(e, i, n) {
            switch (e.event.toLowerCase()) {
              case "ready":
                for (var s in t._data(i[0], "events")) s.match(/loadProgress|playProgress|play|pause|finish|seek|cuechange/) && i[0].contentWindow.postMessage(JSON.stringify({
                    method: "addEventListener",
                    value: s
                }), n);
                if (i.data("vimeoAPICall")) {
                    for (var o = i.data("vimeoAPICall"), a = 0; a < o.length; a++) i[0].contentWindow.postMessage(JSON.stringify(o[a].message), o[a].api);
                    i.removeData("vimeoAPICall");
                }
                i.data("vimeoReady", !0), i.triggerHandler("ready");
                break;

              case "seek":
                i.triggerHandler("seek", [ e.data ]);
                break;

              case "loadprogress":
                i.triggerHandler("loadProgress", [ e.data ]);
                break;

              case "playprogress":
                i.triggerHandler("playProgress", [ e.data ]);
                break;

              case "pause":
                i.triggerHandler("pause");
                break;

              case "finish":
                i.triggerHandler("finish");
                break;

              case "play":
                i.triggerHandler("play");
                break;

              case "cuechange":
                i.triggerHandler("cuechange");
            }
        }
    };
    jQuery(document).ready(function() {
        t("iframe[src*='vimeo.com']").each(function(e) {
            var i = t(this).attr("src");
            if (null === i.match(/player_id/g)) {
                var n = -1 === i.indexOf("?") ? "?" : "&", s = t.param({
                    api: 1,
                    player_id: "vvvvimeoVideo-" + e
                });
                t(this).attr("src", i + n + s);
            }
        });
    }), t(e).on("message", function(t) {
        i.init(t);
    }), t.vimeo = function(t, n, s) {
        var o = {}, a = i.catchMethods.methodreturn.length;
        if ("string" == typeof n && (o.method = n), void 0 !== typeof s && "function" != typeof s && (o.value = s), 
        "iframe" === t.prop("tagName").toLowerCase() && o.hasOwnProperty("method")) if (t.data("vimeoReady")) t[0].contentWindow.postMessage(JSON.stringify(o), i.setVimeoAPIurl(t)); else {
            var r = t.data("vimeoAPICall") ? t.data("vimeoAPICall") : [];
            r.push({
                message: o,
                api: i.setVimeoAPIurl(t)
            }), t.data("vimeoAPICall", r);
        }
        return "get" !== n.toString().substr(0, 3) && "paused" !== n.toString() || "function" != typeof s || (!function(t, n, s) {
            var o = e.setInterval(function() {
                i.catchMethods.methodreturn.length != t && (e.clearInterval(o), n(i.catchMethods.methodreturn[s]));
            }, 10);
        }(a, s, i.catchMethods.count), i.catchMethods.count++), t;
    }, t.fn.vimeo = function(e, i) {
        return t.vimeo(this, e, i);
    };
}(jQuery, window), function() {
    function t(n) {
        if (!n) throw new Error("No options passed to Waypoint constructor");
        if (!n.element) throw new Error("No element option passed to Waypoint constructor");
        if (!n.handler) throw new Error("No handler option passed to Waypoint constructor");
        this.key = "waypoint-" + e, this.options = t.Adapter.extend({}, t.defaults, n), 
        this.element = this.options.element, this.adapter = new t.Adapter(this.element), 
        this.callback = n.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", 
        this.enabled = this.options.enabled, this.triggerPoint = null, this.group = t.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        }), this.context = t.Context.findOrCreateByElement(this.options.context), t.offsetAliases[this.options.offset] && (this.options.offset = t.offsetAliases[this.options.offset]), 
        this.group.add(this), this.context.add(this), i[this.key] = this, e += 1;
    }
    var e = 0, i = {};
    t.prototype.queueTrigger = function(t) {
        this.group.queueTrigger(this, t);
    }, t.prototype.trigger = function(t) {
        this.enabled && this.callback && this.callback.apply(this, t);
    }, t.prototype.destroy = function() {
        this.context.remove(this), this.group.remove(this), delete i[this.key];
    }, t.prototype.disable = function() {
        return this.enabled = !1, this;
    }, t.prototype.enable = function() {
        return this.context.refresh(), this.enabled = !0, this;
    }, t.prototype.next = function() {
        return this.group.next(this);
    }, t.prototype.previous = function() {
        return this.group.previous(this);
    }, t.invokeAll = function(t) {
        var e = [];
        for (var n in i) e.push(i[n]);
        for (var s = 0, o = e.length; o > s; s++) e[s][t]();
    }, t.destroyAll = function() {
        t.invokeAll("destroy");
    }, t.disableAll = function() {
        t.invokeAll("disable");
    }, t.enableAll = function() {
        t.invokeAll("enable");
    }, t.refreshAll = function() {
        t.Context.refreshAll();
    }, t.viewportHeight = function() {
        return window.innerHeight || document.documentElement.clientHeight;
    }, t.viewportWidth = function() {
        return document.documentElement.clientWidth;
    }, t.adapters = [], t.defaults = {
        context: window,
        continuous: !0,
        enabled: !0,
        group: "default",
        horizontal: !1,
        offset: 0
    }, t.offsetAliases = {
        "bottom-in-view": function() {
            return this.context.innerHeight() - this.adapter.outerHeight();
        },
        "right-in-view": function() {
            return this.context.innerWidth() - this.adapter.outerWidth();
        }
    }, window.Waypoint = t;
}(), function() {
    function t(t) {
        window.setTimeout(t, 1e3 / 60);
    }
    function e(t) {
        this.element = t, this.Adapter = s.Adapter, this.adapter = new this.Adapter(t), 
        this.key = "waypoint-context-" + i, this.didScroll = !1, this.didResize = !1, this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        }, this.waypoints = {
            vertical: {},
            horizontal: {}
        }, t.waypointContextKey = this.key, n[t.waypointContextKey] = this, i += 1, this.createThrottledScrollHandler(), 
        this.createThrottledResizeHandler();
    }
    var i = 0, n = {}, s = window.Waypoint, o = window.onload;
    e.prototype.add = function(t) {
        var e = t.options.horizontal ? "horizontal" : "vertical";
        this.waypoints[e][t.key] = t, this.refresh();
    }, e.prototype.checkEmpty = function() {
        var t = this.Adapter.isEmptyObject(this.waypoints.horizontal), e = this.Adapter.isEmptyObject(this.waypoints.vertical);
        t && e && (this.adapter.off(".waypoints"), delete n[this.key]);
    }, e.prototype.createThrottledResizeHandler = function() {
        function t() {
            e.handleResize(), e.didResize = !1;
        }
        var e = this;
        this.adapter.on("resize.waypoints", function() {
            e.didResize || (e.didResize = !0, s.requestAnimationFrame(t));
        });
    }, e.prototype.createThrottledScrollHandler = function() {
        function t() {
            e.handleScroll(), e.didScroll = !1;
        }
        var e = this;
        this.adapter.on("scroll.waypoints", function() {
            (!e.didScroll || s.isTouch) && (e.didScroll = !0, s.requestAnimationFrame(t));
        });
    }, e.prototype.handleResize = function() {
        s.Context.refreshAll();
    }, e.prototype.handleScroll = function() {
        var t = {}, e = {
            horizontal: {
                newScroll: this.adapter.scrollLeft(),
                oldScroll: this.oldScroll.x,
                forward: "right",
                backward: "left"
            },
            vertical: {
                newScroll: this.adapter.scrollTop(),
                oldScroll: this.oldScroll.y,
                forward: "down",
                backward: "up"
            }
        };
        for (var i in e) {
            var n = e[i], s = n.newScroll > n.oldScroll ? n.forward : n.backward;
            for (var o in this.waypoints[i]) {
                var a = this.waypoints[i][o], r = n.oldScroll < a.triggerPoint, l = n.newScroll >= a.triggerPoint, h = r && l, c = !r && !l;
                (h || c) && (a.queueTrigger(s), t[a.group.id] = a.group);
            }
        }
        for (var u in t) t[u].flushTriggers();
        this.oldScroll = {
            x: e.horizontal.newScroll,
            y: e.vertical.newScroll
        };
    }, e.prototype.innerHeight = function() {
        return this.element == this.element.window ? s.viewportHeight() : this.adapter.innerHeight();
    }, e.prototype.remove = function(t) {
        delete this.waypoints[t.axis][t.key], this.checkEmpty();
    }, e.prototype.innerWidth = function() {
        return this.element == this.element.window ? s.viewportWidth() : this.adapter.innerWidth();
    }, e.prototype.destroy = function() {
        var t = [];
        for (var e in this.waypoints) for (var i in this.waypoints[e]) t.push(this.waypoints[e][i]);
        for (var n = 0, s = t.length; s > n; n++) t[n].destroy();
    }, e.prototype.refresh = function() {
        var t, e = this.element == this.element.window, i = e ? void 0 : this.adapter.offset(), n = {};
        this.handleScroll(), t = {
            horizontal: {
                contextOffset: e ? 0 : i.left,
                contextScroll: e ? 0 : this.oldScroll.x,
                contextDimension: this.innerWidth(),
                oldScroll: this.oldScroll.x,
                forward: "right",
                backward: "left",
                offsetProp: "left"
            },
            vertical: {
                contextOffset: e ? 0 : i.top,
                contextScroll: e ? 0 : this.oldScroll.y,
                contextDimension: this.innerHeight(),
                oldScroll: this.oldScroll.y,
                forward: "down",
                backward: "up",
                offsetProp: "top"
            }
        };
        for (var o in t) {
            var a = t[o];
            for (var r in this.waypoints[o]) {
                var l, h, c, u, d, f = this.waypoints[o][r], p = f.options.offset, g = f.triggerPoint, v = 0, m = null == g;
                f.element !== f.element.window && (v = f.adapter.offset()[a.offsetProp]), "function" == typeof p ? p = p.apply(f) : "string" == typeof p && (p = parseFloat(p), 
                f.options.offset.indexOf("%") > -1 && (p = Math.ceil(a.contextDimension * p / 100))), 
                l = a.contextScroll - a.contextOffset, f.triggerPoint = v + l - p, h = g < a.oldScroll, 
                c = f.triggerPoint >= a.oldScroll, u = h && c, d = !h && !c, !m && u ? (f.queueTrigger(a.backward), 
                n[f.group.id] = f.group) : !m && d ? (f.queueTrigger(a.forward), n[f.group.id] = f.group) : m && a.oldScroll >= f.triggerPoint && (f.queueTrigger(a.forward), 
                n[f.group.id] = f.group);
            }
        }
        return s.requestAnimationFrame(function() {
            for (var t in n) n[t].flushTriggers();
        }), this;
    }, e.findOrCreateByElement = function(t) {
        return e.findByElement(t) || new e(t);
    }, e.refreshAll = function() {
        for (var t in n) n[t].refresh();
    }, e.findByElement = function(t) {
        return n[t.waypointContextKey];
    }, window.onload = function() {
        o && o(), e.refreshAll();
    }, s.requestAnimationFrame = function(e) {
        (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || t).call(window, e);
    }, s.Context = e;
}(), function() {
    function t(t, e) {
        return t.triggerPoint - e.triggerPoint;
    }
    function e(t, e) {
        return e.triggerPoint - t.triggerPoint;
    }
    function i(t) {
        this.name = t.name, this.axis = t.axis, this.id = this.name + "-" + this.axis, this.waypoints = [], 
        this.clearTriggerQueues(), n[this.axis][this.name] = this;
    }
    var n = {
        vertical: {},
        horizontal: {}
    }, s = window.Waypoint;
    i.prototype.add = function(t) {
        this.waypoints.push(t);
    }, i.prototype.clearTriggerQueues = function() {
        this.triggerQueues = {
            up: [],
            down: [],
            left: [],
            right: []
        };
    }, i.prototype.flushTriggers = function() {
        for (var i in this.triggerQueues) {
            var n = this.triggerQueues[i], s = "up" === i || "left" === i;
            n.sort(s ? e : t);
            for (var o = 0, a = n.length; a > o; o += 1) {
                var r = n[o];
                (r.options.continuous || o === n.length - 1) && r.trigger([ i ]);
            }
        }
        this.clearTriggerQueues();
    }, i.prototype.next = function(e) {
        this.waypoints.sort(t);
        var i = s.Adapter.inArray(e, this.waypoints);
        return i === this.waypoints.length - 1 ? null : this.waypoints[i + 1];
    }, i.prototype.previous = function(e) {
        this.waypoints.sort(t);
        var i = s.Adapter.inArray(e, this.waypoints);
        return i ? this.waypoints[i - 1] : null;
    }, i.prototype.queueTrigger = function(t, e) {
        this.triggerQueues[e].push(t);
    }, i.prototype.remove = function(t) {
        var e = s.Adapter.inArray(t, this.waypoints);
        e > -1 && this.waypoints.splice(e, 1);
    }, i.prototype.first = function() {
        return this.waypoints[0];
    }, i.prototype.last = function() {
        return this.waypoints[this.waypoints.length - 1];
    }, i.findOrCreate = function(t) {
        return n[t.axis][t.name] || new i(t);
    }, s.Group = i;
}(), function() {
    function t(t) {
        this.$element = e(t);
    }
    var e = window.jQuery, i = window.Waypoint;
    e.each([ "innerHeight", "innerWidth", "off", "offset", "on", "outerHeight", "outerWidth", "scrollLeft", "scrollTop" ], function(e, i) {
        t.prototype[i] = function() {
            var t = Array.prototype.slice.call(arguments);
            return this.$element[i].apply(this.$element, t);
        };
    }), e.each([ "extend", "inArray", "isEmptyObject" ], function(i, n) {
        t[n] = e[n];
    }), i.adapters.push({
        name: "jquery",
        Adapter: t
    }), i.Adapter = t;
}(), function() {
    function t(t) {
        return function() {
            var i = [], n = arguments[0];
            return t.isFunction(arguments[0]) && (n = t.extend({}, arguments[1]), n.handler = arguments[0]), 
            this.each(function() {
                var s = t.extend({}, n, {
                    element: this
                });
                "string" == typeof s.context && (s.context = t(this).closest(s.context)[0]), i.push(new e(s));
            }), i;
        };
    }
    var e = window.Waypoint;
    window.jQuery && (window.jQuery.fn.waypoint = t(window.jQuery)), window.Zepto && (window.Zepto.fn.waypoint = t(window.Zepto));
}(), function(t) {
    function e() {
        t(".wp-1").waypoint(function() {
            t(".wp-1").addClass("animated fadeInUp");
        }, {
            offset: "75%"
        }), t(".wp-2").waypoint(function() {
            t(".wp-2").addClass("animated fadeInUp");
        }, {
            offset: "75%"
        }), t(".wp-3").waypoint(function() {
            t(".wp-3").addClass("animated fadeInUp");
        }, {
            offset: "75%"
        }), t(".wp-4").waypoint(function() {
            t(".wp-4").addClass("animated fadeIn");
        }, {
            offset: "75%"
        }), t(".wp-5").waypoint(function() {
            t(".wp-5").addClass("animated fadeInRight");
        }, {
            offset: "50%"
        }), t(".wp-6").waypoint(function() {
            t(".wp-6").addClass("animated fadeInLeft");
        }, {
            offset: "50%"
        }), t(".wp-7").waypoint(function() {
            t(".wp-7").addClass("animated fadeInUp");
        }, {
            offset: "60%"
        }), t(".wp-8").waypoint(function() {
            t(".wp-8").addClass("animated fadeInUp");
        }, {
            offset: "60%"
        });
    }
    function i() {
        t("input, textarea").placeholder();
    }
    function n() {
        t(".scroll-top").on("click", function() {
            return t("html, body").animate({
                scrollTop: 0
            }, 1e3), !1;
        });
    }
    function s() {
        var t = [ {
            value: 324,
            color: "#5e98e3",
            highlight: "#424753",
            label: "Completed"
        }, {
            value: 34,
            color: "#59d0bd",
            highlight: "#424753",
            label: "In backlog"
        }, {
            value: 20,
            color: "#e8e9ec",
            highlight: "#424753",
            label: "Without ticket"
        } ];
        window.onload = function() {
            var e = document.getElementById("chart-area");
            if (null == e) return !1;
            var i = e.getContext("2d");
            window.myDoughnut = new Chart(i).Doughnut(t, {
                responsive: !0,
                percentageInnerCutout: 80
            });
        };
    }
    function o() {
        t("#videoModal").on("shown.bs.modal", function() {
            t("#vimeo-play").vimeo("play");
        }), t("#videoModal").on("hidden.bs.modal", function() {
            t("#vimeo-play").vimeo("pause");
        }), t("#youtube-trigger").click(function() {
            var e = t(this).attr("data-video"), i = e + "?autoplay=1&html5=1&rel=0&showinfo=0";
            t("#youtubeModal").on("shown.bs.modal", function() {
                t("#youtube-play").attr("src", i);
            }), t("#youtubeModal").on("hidden.bs.modal", function() {
                t("#youtube-play").attr("src", e);
            });
        });
    }
    !function() {
        e(), i(), n(), s(), o();
    }();
}(jQuery);